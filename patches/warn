Bottom: 3e71bc7dd8b816c805a2865b96b982df0f62f53a
Top:    9386a7c7dae2d64a41239e3a93442d13443ac1e1
Author: scott snyder <sss@karma>
Date:   2020-02-12 11:51:18 -0500

Fix compilation warnings.


---

diff --git a/Analysis/AddClusterProperties/src/AddClusterProperties.cc b/Analysis/AddClusterProperties/src/AddClusterProperties.cc
index 9780afb..5a88023 100644
--- a/Analysis/AddClusterProperties/src/AddClusterProperties.cc
+++ b/Analysis/AddClusterProperties/src/AddClusterProperties.cc
@@ -117,7 +117,7 @@ void AddClusterProperties::processEvent( LCEvent * evt ) {
 	  if ( subDetectorNames[kkk] == "bcal"  )   { bcal_index  = kkk ;  }
         }
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _clusterCollectionName   << " collection not available" << std::endl;
         clucol = NULL;
@@ -212,8 +212,7 @@ void AddClusterProperties::processEvent( LCEvent * evt ) {
         shape[sum_wgt4_index]=sum_wgt4; 
  
 
-        float Eerror=clu->getEnergyError();
-        if ( Eerror == 0.0 ) {
+        if ( clu->getEnergyError() == 0.0 ) {
             // not set, so as per HLRWS:
           float E=clu->getEnergy();
           const FloatVec pec  = clu->getSubdetectorEnergies();
@@ -262,7 +261,7 @@ void AddClusterProperties::processEvent( LCEvent * evt ) {
     try{
       pfocol = evt->getCollection( _PFOName );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) << _PFOName    << " collection not available" << std::endl;
         pfocol = NULL;
diff --git a/Analysis/CLICPfoSelector/include/PfoUtilities.h b/Analysis/CLICPfoSelector/include/PfoUtilities.h
index c04f496..000f0db 100644
--- a/Analysis/CLICPfoSelector/include/PfoUtilities.h
+++ b/Analysis/CLICPfoSelector/include/PfoUtilities.h
@@ -47,7 +47,8 @@ namespace PfoUtil {
 
   typedef std::vector<EVENT::ReconstructedParticle*> PfoList;
 
-  static bool PfoSortFunction(EVENT::ReconstructedParticle* lhs, EVENT::ReconstructedParticle* rhs) {
+  inline
+  bool PfoSortFunction(EVENT::ReconstructedParticle* lhs, EVENT::ReconstructedParticle* rhs) {
     //  true if lhs goes before
 
     const float             lhs_energy       = lhs->getEnergy();
diff --git a/Analysis/CLICPfoSelector/src/CLICPfoSelectorAnalysis.cc b/Analysis/CLICPfoSelector/src/CLICPfoSelectorAnalysis.cc
index 041a4fe..625e5de 100644
--- a/Analysis/CLICPfoSelector/src/CLICPfoSelectorAnalysis.cc
+++ b/Analysis/CLICPfoSelector/src/CLICPfoSelectorAnalysis.cc
@@ -186,7 +186,7 @@ void CLICPfoSelectorAnalysis::processEvent(LCEvent* evt) {
   LCCollection* physicsParticleCollection = NULL;
   try {
     physicsParticleCollection = evt->getCollection(m_inputPhysicsParticleCollection);
-  } catch (lcio::DataNotAvailableException e) {
+  } catch (const lcio::DataNotAvailableException& e) {
     streamlog_out(WARNING) << m_inputPhysicsParticleCollection << " collection not available" << std::endl;
     physicsParticleCollection = NULL;
   }
@@ -200,7 +200,7 @@ void CLICPfoSelectorAnalysis::processEvent(LCEvent* evt) {
   LCCollection* rmclcol = NULL;
   try {
     rmclcol = evt->getCollection(m_recoMCTruthLink);
-  } catch (lcio::DataNotAvailableException e) {
+  } catch (const lcio::DataNotAvailableException& e) {
     streamlog_out(WARNING) << m_recoMCTruthLink << " collection not available" << std::endl;
     rmclcol = NULL;
   }
@@ -212,7 +212,7 @@ void CLICPfoSelectorAnalysis::processEvent(LCEvent* evt) {
   LCCollection* rtrkclcol = NULL;
   try {
     rtrkclcol = evt->getCollection(m_SiTracksMCTruthLink);
-  } catch (lcio::DataNotAvailableException e) {
+  } catch (const lcio::DataNotAvailableException& e) {
     streamlog_out(WARNING) << m_SiTracksMCTruthLink << " collection not available" << std::endl;
     rtrkclcol = NULL;
   }
@@ -224,7 +224,7 @@ void CLICPfoSelectorAnalysis::processEvent(LCEvent* evt) {
   LCCollection* rclulcol = NULL;
   try {
     rclulcol = evt->getCollection(m_ClusterMCTruthLink);
-  } catch (lcio::DataNotAvailableException e) {
+  } catch (const lcio::DataNotAvailableException& e) {
     streamlog_out(WARNING) << m_ClusterMCTruthLink << " collection not available" << std::endl;
     rclulcol = NULL;
   }
diff --git a/Analysis/EventShapes/include/jama_eig.h b/Analysis/EventShapes/include/jama_eig.h
index e0e9a3f..7215507 100644
--- a/Analysis/EventShapes/include/jama_eig.h
+++ b/Analysis/EventShapes/include/jama_eig.h
@@ -362,17 +362,17 @@ class Eigenvalue
 
    float cdivr{}, cdivi{};
    void cdiv(float xr, float xi, float yr, float yi) {
-      float r,d;
+      float r,d_;
       if (abs(yr) > abs(yi)) {
          r = yi/yr;
-         d = yr + r*yi;
-         cdivr = (xr + r*xi)/d;
-         cdivi = (xi - r*xr)/d;
+         d_ = yr + r*yi;
+         cdivr = (xr + r*xi)/d_;
+         cdivi = (xi - r*xr)/d_;
       } else {
          r = yr/yi;
-         d = yi + r*yr;
-         cdivr = (r*xr + xi)/d;
-         cdivi = (r*xi - xr)/d;
+         d_ = yi + r*yr;
+         cdivr = (r*xr + xi)/d_;
+         cdivi = (r*xi - xr)/d_;
       }
    }
 
@@ -389,7 +389,7 @@ class Eigenvalue
       // Initialize
    
       int nn = 3;
-      int n = nn-1;
+      int n_ = nn-1;
       int low = 0;
       int high = nn-1;
       float eps = pow(2.0,-52.0);
@@ -412,11 +412,11 @@ class Eigenvalue
       // Outer loop over eigenvalue index
    
       int iter = 0;
-      while (n >= low) {
+      while (n_ >= low) {
    
          // Look for single small sub-diagonal element
    
-         int l = n;
+         int l = n_;
          while (l > low) {
             s = abs(H[l-1][l-1]) + abs(H[l][l]);
             if (s == 0.0) {
@@ -431,23 +431,23 @@ class Eigenvalue
          // Check for convergence
          // One root found
    
-         if (l == n) {
-            H[n][n] = H[n][n] + exshift;
-            d[n] = H[n][n];
-            e[n] = 0.0;
-            n--;
+         if (l == n_) {
+            H[n_][n_] = H[n_][n_] + exshift;
+            d[n_] = H[n_][n_];
+            e[n_] = 0.0;
+            n_--;
             iter = 0;
    
          // Two roots found
    
-         } else if (l == n-1) {
-            w = H[n][n-1] * H[n-1][n];
-            p = (H[n-1][n-1] - H[n][n]) / 2.0;
+         } else if (l == n_-1) {
+            w = H[n_][n_-1] * H[n_-1][n_];
+            p = (H[n_-1][n_-1] - H[n_][n_]) / 2.0;
             q = p * p + w;
             z = sqrt(abs(q));
-            H[n][n] = H[n][n] + exshift;
-            H[n-1][n-1] = H[n-1][n-1] + exshift;
-            x = H[n][n];
+            H[n_][n_] = H[n_][n_] + exshift;
+            H[n_-1][n_-1] = H[n_-1][n_-1] + exshift;
+            x = H[n_][n_];
    
             // float pair
    
@@ -457,14 +457,14 @@ class Eigenvalue
                } else {
                   z = p - z;
                }
-               d[n-1] = x + z;
-               d[n] = d[n-1];
+               d[n_-1] = x + z;
+               d[n_] = d[n_-1];
                if (z != 0.0) {
-                  d[n] = x - w / z;
+                  d[n_] = x - w / z;
                }
-               e[n-1] = 0.0;
-               e[n] = 0.0;
-               x = H[n][n-1];
+               e[n_-1] = 0.0;
+               e[n_] = 0.0;
+               x = H[n_][n_-1];
                s = abs(x) + abs(z);
                p = x / s;
                q = z / s;
@@ -474,37 +474,37 @@ class Eigenvalue
    
                // Row modification
    
-               for (int j = n-1; j < nn; j++) {
-                  z = H[n-1][j];
-                  H[n-1][j] = q * z + p * H[n][j];
-                  H[n][j] = q * H[n][j] - p * z;
+               for (int j = n_-1; j < nn; j++) {
+                  z = H[n_-1][j];
+                  H[n_-1][j] = q * z + p * H[n_][j];
+                  H[n_][j] = q * H[n_][j] - p * z;
                }
    
                // Column modification
    
-               for (int i = 0; i <= n; i++) {
-                  z = H[i][n-1];
-                  H[i][n-1] = q * z + p * H[i][n];
-                  H[i][n] = q * H[i][n] - p * z;
+               for (int i = 0; i <= n_; i++) {
+                  z = H[i][n_-1];
+                  H[i][n_-1] = q * z + p * H[i][n_];
+                  H[i][n_] = q * H[i][n_] - p * z;
                }
    
                // Accumulate transformations
    
                for (int i = low; i <= high; i++) {
-                  z = V[i][n-1];
-                  V[i][n-1] = q * z + p * V[i][n];
-                  V[i][n] = q * V[i][n] - p * z;
+                  z = V[i][n_-1];
+                  V[i][n_-1] = q * z + p * V[i][n_];
+                  V[i][n_] = q * V[i][n_] - p * z;
                }
    
             // Complex pair
    
             } else {
-               d[n-1] = x + p;
-               d[n] = x + p;
-               e[n-1] = z;
-               e[n] = -z;
+               d[n_-1] = x + p;
+               d[n_] = x + p;
+               e[n_-1] = z;
+               e[n_] = -z;
             }
-            n = n - 2;
+            n_ = n_ - 2;
             iter = 0;
    
          // No convergence yet
@@ -513,22 +513,22 @@ class Eigenvalue
    
             // Form shift
    
-            x = H[n][n];
+            x = H[n_][n_];
             y = 0.0;
             w = 0.0;
-            if (l < n) {
-               y = H[n-1][n-1];
-               w = H[n][n-1] * H[n-1][n];
+            if (l < n_) {
+               y = H[n_-1][n_-1];
+               w = H[n_][n_-1] * H[n_-1][n_];
             }
    
             // Wilkinson's original ad hoc shift
    
             if (iter == 10) {
                exshift += x;
-               for (int i = low; i <= n; i++) {
+               for (int i = low; i <= n_; i++) {
                   H[i][i] -= x;
                }
-               s = abs(H[n][n-1]) + abs(H[n-1][n-2]);
+               s = abs(H[n_][n_-1]) + abs(H[n_-1][n_-2]);
                x = y = 0.75 * s;
                w = -0.4375 * s * s;
             }
@@ -544,7 +544,7 @@ class Eigenvalue
                        s = -s;
                     }
                     s = x - w / ((y - x) / 2.0 + s);
-                    for (int i = low; i <= n; i++) {
+                    for (int i = low; i <= n_; i++) {
                        H[i][i] -= s;
                     }
                     exshift += s;
@@ -558,7 +558,7 @@ class Eigenvalue
 // for abs() below
             // Look for two consecutive small sub-diagonal elements
    
-            int m = n-2;
+            int m = n_-2;
             while (m >= l) {
                z = H[m][m];
                r = x - z;
@@ -583,7 +583,7 @@ class Eigenvalue
                m--;
             }
    
-            for (int i = m+2; i <= n; i++) {
+            for (int i = m+2; i <= n_; i++) {
                H[i][i-2] = 0.0;
                if (i > m+2) {
                   H[i][i-3] = 0.0;
@@ -592,8 +592,8 @@ class Eigenvalue
    
             // Float QR step involving rows l:n and columns m:n
    
-            for (int k = m; k <= n-1; k++) {
-               int notlast = (k != n-1);
+            for (int k = m; k <= n_-1; k++) {
+               int notlast = (k != n_-1);
                if (k != m) {
                   p = H[k][k-1];
                   q = H[k+1][k-1];
@@ -639,7 +639,7 @@ class Eigenvalue
    
                   // Column modification
    
-                  for (int i = 0; i <= min(n,k+3); i++) {
+                  for (int i = 0; i <= min(n_,k+3); i++) {
                      p = x * H[i][k] + y * H[i][k+1];
                      if (notlast) {
                         p = p + z * H[i][k+2];
@@ -663,7 +663,7 @@ class Eigenvalue
                }  // (s != 0)
             }  // k loop
          }  // check convergence
-      }  // while (n >= low)
+      }  // while (n_ >= low)
       
       // Backsubstitute to find vectors of upper triangular form
 
@@ -671,20 +671,20 @@ class Eigenvalue
          return;
       }
    
-      for (n = nn-1; n >= 0; n--) {
-         p = d[n];
-         q = e[n];
+      for (n_ = nn-1; n_ >= 0; n_--) {
+         p = d[n_];
+         q = e[n_];
    
          // float vector
    
          if (q == 0) {
-            int l = n;
-            H[n][n] = 1.0;
-            for (int i = n-1; i >= 0; i--) {
+            int l = n_;
+            H[n_][n_] = 1.0;
+            for (int i = n_-1; i >= 0; i--) {
                w = H[i][i] - p;
                r = 0.0;
-               for (int j = l; j <= n; j++) {
-                  r = r + H[i][j] * H[j][n];
+               for (int j = l; j <= n_; j++) {
+                  r = r + H[i][j] * H[j][n_];
                }
                if (e[i] < 0.0) {
                   z = w;
@@ -693,9 +693,9 @@ class Eigenvalue
                   l = i;
                   if (e[i] == 0.0) {
                      if (w != 0.0) {
-                        H[i][n] = -r / w;
+                        H[i][n_] = -r / w;
                      } else {
-                        H[i][n] = -r / (eps * norm);
+                        H[i][n_] = -r / (eps * norm);
                      }
    
                   // Solve real equations
@@ -705,20 +705,20 @@ class Eigenvalue
                      y = H[i+1][i];
                      q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                      t = (x * s - z * r) / q;
-                     H[i][n] = t;
+                     H[i][n_] = t;
                      if (abs(x) > abs(z)) {
-                        H[i+1][n] = (-r - w * t) / x;
+                        H[i+1][n_] = (-r - w * t) / x;
                      } else {
-                        H[i+1][n] = (-s - y * t) / z;
+                        H[i+1][n_] = (-s - y * t) / z;
                      }
                   }
    
                   // Overflow control
    
-                  t = abs(H[i][n]);
+                  t = abs(H[i][n_]);
                   if ((eps * t) * t > 1) {
-                     for (int j = i; j <= n; j++) {
-                        H[j][n] = H[j][n] / t;
+                     for (int j = i; j <= n_; j++) {
+                        H[j][n_] = H[j][n_] / t;
                      }
                   }
                }
@@ -727,27 +727,27 @@ class Eigenvalue
          // Complex vector
    
          } else if (q < 0) {
-            int l = n-1;
+            int l = n_-1;
 
             // Last vector component imaginary so matrix is triangular
    
-            if (abs(H[n][n-1]) > abs(H[n-1][n])) {
-               H[n-1][n-1] = q / H[n][n-1];
-               H[n-1][n] = -(H[n][n] - p) / H[n][n-1];
+            if (abs(H[n_][n_-1]) > abs(H[n_-1][n_])) {
+               H[n_-1][n_-1] = q / H[n_][n_-1];
+               H[n_-1][n_] = -(H[n_][n_] - p) / H[n_][n_-1];
             } else {
-               cdiv(0.0,-H[n-1][n],H[n-1][n-1]-p,q);
-               H[n-1][n-1] = cdivr;
-               H[n-1][n] = cdivi;
+               cdiv(0.0,-H[n_-1][n_],H[n_-1][n_-1]-p,q);
+               H[n_-1][n_-1] = cdivr;
+               H[n_-1][n_] = cdivi;
             }
-            H[n][n-1] = 0.0;
-            H[n][n] = 1.0;
-            for (int i = n-2; i >= 0; i--) {
+            H[n_][n_-1] = 0.0;
+            H[n_][n_] = 1.0;
+            for (int i = n_-2; i >= 0; i--) {
                float ra,sa,vr,vi;
                ra = 0.0;
                sa = 0.0;
-               for (int j = l; j <= n; j++) {
-                  ra = ra + H[i][j] * H[j][n-1];
-                  sa = sa + H[i][j] * H[j][n];
+               for (int j = l; j <= n_; j++) {
+                  ra = ra + H[i][j] * H[j][n_-1];
+                  sa = sa + H[i][j] * H[j][n_];
                }
                w = H[i][i] - p;
    
@@ -759,8 +759,8 @@ class Eigenvalue
                   l = i;
                   if (e[i] == 0) {
                      cdiv(-ra,-sa,w,q);
-                     H[i][n-1] = cdivr;
-                     H[i][n] = cdivi;
+                     H[i][n_-1] = cdivr;
+                     H[i][n_] = cdivi;
                   } else {
    
                      // Solve complex equations
@@ -774,25 +774,25 @@ class Eigenvalue
                         abs(x) + abs(y) + abs(z));
                      }
                      cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi);
-                     H[i][n-1] = cdivr;
-                     H[i][n] = cdivi;
+                     H[i][n_-1] = cdivr;
+                     H[i][n_] = cdivi;
                      if (abs(x) > (abs(z) + abs(q))) {
-                        H[i+1][n-1] = (-ra - w * H[i][n-1] + q * H[i][n]) / x;
-                        H[i+1][n] = (-sa - w * H[i][n] - q * H[i][n-1]) / x;
+                        H[i+1][n_-1] = (-ra - w * H[i][n_-1] + q * H[i][n_]) / x;
+                        H[i+1][n_] = (-sa - w * H[i][n_] - q * H[i][n_-1]) / x;
                      } else {
-                        cdiv(-r-y*H[i][n-1],-s-y*H[i][n],z,q);
-                        H[i+1][n-1] = cdivr;
-                        H[i+1][n] = cdivi;
+                        cdiv(-r-y*H[i][n_-1],-s-y*H[i][n_],z,q);
+                        H[i+1][n_-1] = cdivr;
+                        H[i+1][n_] = cdivi;
                      }
                   }
    
                   // Overflow control
 
-                  t = max(abs(H[i][n-1]),abs(H[i][n]));
+                  t = max(abs(H[i][n_-1]),abs(H[i][n_]));
                   if ((eps * t) * t > 1) {
-                     for (int j = i; j <= n; j++) {
-                        H[j][n-1] = H[j][n-1] / t;
-                        H[j][n] = H[j][n] / t;
+                     for (int j = i; j <= n_; j++) {
+                        H[j][n_-1] = H[j][n_-1] / t;
+                        H[j][n_] = H[j][n_] / t;
                      }
                   }
                }
diff --git a/Analysis/EventShapes/src/Sphere.cc b/Analysis/EventShapes/src/Sphere.cc
index afec14f..be2f9cc 100644
--- a/Analysis/EventShapes/src/Sphere.cc
+++ b/Analysis/EventShapes/src/Sphere.cc
@@ -95,7 +95,7 @@ void Sphere::processEvent( LCEvent * evt ) {
   LCCollection* col ; 
   
   try{ col = evt -> getCollection( _colName ) ; }
-  catch(EVENT::DataNotAvailableException){
+  catch(const EVENT::DataNotAvailableException&){
     streamlog_out(DEBUG)  << "Cannot find PFO Collection in event/run  " << evt->getEventNumber() <<" / "<< evt->getRunNumber() <<std::endl;
    streamlog_out(DEBUG) << "Skipping this event!" << std::endl;
    throw marlin::SkipEventException(this);
diff --git a/Analysis/EventShapes/src/ThrustReconstruction.cc b/Analysis/EventShapes/src/ThrustReconstruction.cc
index 8a540e8..0f2668e 100644
--- a/Analysis/EventShapes/src/ThrustReconstruction.cc
+++ b/Analysis/EventShapes/src/ThrustReconstruction.cc
@@ -268,7 +268,7 @@ int ThrustReconstruction::JetsetThrust(){
   const float dConv=0.0001; // 0.0001
   int sgn;
   double theta=0,phi=0;
-  double thp,thps,tds,tmax,dOblateness;
+  double thp,thps,tds,tmax;
   vector<Hep3Vector> TAxes(3),Fast(iFastMax+1),Workv(nwork);
   vector<double> Workf(nwork),dThrust(3);
   Hep3Vector tdi,tpr,mytest;
@@ -408,7 +408,6 @@ int ThrustReconstruction::JetsetThrust(){
       TAxes[i].rotateY(theta); 
       TAxes[i].rotateZ(phi); 
     }
-  dOblateness = dThrust[1] - dThrust[2];
 
   _principleThrustValue = dThrust[0];
   _majorThrustValue     = dThrust[1];
diff --git a/Analysis/GammaGammaCandidateFinder/src/GammaGammaCandidateFinder.cc b/Analysis/GammaGammaCandidateFinder/src/GammaGammaCandidateFinder.cc
index 1b44aff..2a4d62c 100644
--- a/Analysis/GammaGammaCandidateFinder/src/GammaGammaCandidateFinder.cc
+++ b/Analysis/GammaGammaCandidateFinder/src/GammaGammaCandidateFinder.cc
@@ -264,8 +264,8 @@ void GammaGammaCandidateFinder::FindGammaGammaCandidates(LCCollectionVec * recpa
              std::cout << "Fit probability = " << fit_probability << std::endl;
              std::cout << "Covariance matrix dimension " << cov_dim << std::endl;
              if(cov_dim==6){
-                for (unsigned int i=0; i<6*6; i++){
-                    std::cout << "Covariance matrix element " << i << " " << cov[i] << std::endl;                   
+                for (unsigned int k=0; k<6*6; k++){
+                    std::cout << "Covariance matrix element " << k << " " << cov[k] << std::endl;                   
                 }
              }
           }
diff --git a/Analysis/GammaGammaHadronRemoval/src/TrackZVertexGrouping.cc b/Analysis/GammaGammaHadronRemoval/src/TrackZVertexGrouping.cc
index aefa429..1d582f6 100644
--- a/Analysis/GammaGammaHadronRemoval/src/TrackZVertexGrouping.cc
+++ b/Analysis/GammaGammaHadronRemoval/src/TrackZVertexGrouping.cc
@@ -144,7 +144,7 @@ void TrackZVertexGrouping::processEvent( LCEvent * evt ) {
   try{
     colTrk = evt->getCollection( _colNameTracks ) ;
   }
-  catch(lcio::Exception){
+  catch(const lcio::Exception&){
     streamlog_out( DEBUG6 ) << " collection " << _colNameTracks
 			    << " not found in event - nothing to do ... " << std::endl ;
   }
diff --git a/Analysis/GammaGammaSolutionFinder/src/GammaGammaSolutionFinder.cc b/Analysis/GammaGammaSolutionFinder/src/GammaGammaSolutionFinder.cc
index 2a2476c..3b7a08f 100644
--- a/Analysis/GammaGammaSolutionFinder/src/GammaGammaSolutionFinder.cc
+++ b/Analysis/GammaGammaSolutionFinder/src/GammaGammaSolutionFinder.cc
@@ -473,8 +473,8 @@ void GammaGammaSolutionFinder::FindGammaGammaSolutions(LCCollectionVec * recparc
        nfirst_vertices++;     
        if(_printing>6)std::cout << std::setw(2) << i << " " << std::setw(2) << fvec[i].ivertex << " " 
                                 << std::setw(2) << fvec[i].nedges << " " << fvec[i].febits << "  { "; 
-       for (std::list<int>::iterator it=fvec[i].fvelist.begin(); it!=fvec[i].fvelist.end(); ++it){
-           if(_printing>6)std::cout << std::setw(2) << *it << " ";
+       for (std::list<int>::iterator it2=fvec[i].fvelist.begin(); it2!=fvec[i].fvelist.end(); ++it2){
+           if(_printing>6)std::cout << std::setw(2) << *it2 << " ";
        } 
        if(_printing>6)std::cout << "}" << std::endl;
    }
@@ -487,7 +487,7 @@ void GammaGammaSolutionFinder::FindGammaGammaSolutions(LCCollectionVec * recparc
   // version, but has the advantage that it will return "false" if the
   // matching returned is not actually a maximum cardinality matching
   // in the graph.
-   bool success = checked_edmonds_maximum_cardinality_matching(g, &mate[0]);
+   bool success [[maybe_unused]] = checked_edmonds_maximum_cardinality_matching(g, &mate[0]);
    assert(success);
    if(_printing>6)std::cout << std::endl << "Found a matching of size " << matching_size(g, &mate[0]) << std::endl;
    if(_printing>6)std::cout << "The matching is:" << std::endl;
@@ -556,9 +556,9 @@ void GammaGammaSolutionFinder::FindGammaGammaSolutions(LCCollectionVec * recparc
            std::vector<int> tmp;
            if(fvec[d[i]].nedges>1){    // Only do this for those first vertices with more than one edge
 // Iterate over the elements of the list associated with first vertex d[i]
-              for (std::list<int>::iterator it=fvec[d[i]].fvelist.begin(); it!=fvec[d[i]].fvelist.end(); ++it){
-//                std::cout << std::setw(2) << *it << " ";
-                  tmp.push_back(*it);
+              for (std::list<int>::iterator it2=fvec[d[i]].fvelist.begin(); it2!=fvec[d[i]].fvelist.end(); ++it2){
+//                std::cout << std::setw(2) << *it2 << " ";
+                  tmp.push_back(*it2);
               }
 //            std::cout << std::endl;
               array.push_back(tmp);
@@ -587,9 +587,9 @@ void GammaGammaSolutionFinder::FindGammaGammaSolutions(LCCollectionVec * recparc
 
 // Check to see how many vertices are used in this edge set
        ored_vbits = evec[c[0]].vbits;
-       for (unsigned int i=1; i<r; ++i){
-            ored_vbits = (ored_vbits | evec[c[i]].vbits);
-            if(ored_vbits.count()!=2*(i+1))break;
+       for (unsigned int j=1; j<r; ++j){
+            ored_vbits = (ored_vbits | evec[c[j]].vbits);
+            if(ored_vbits.count()!=2*(j+1))break;
        }
        size_t nused = ored_vbits.count();
 
@@ -602,17 +602,17 @@ void GammaGammaSolutionFinder::FindGammaGammaSolutions(LCCollectionVec * recparc
           int npi0 = 0;
           int neta = 0;
           int netap = 0;
-          for (unsigned int i=0; i<r; ++i){
+          for (unsigned int j=0; j<r; ++j){
 /*              std::cout << "Assigned edge details" << std::endl;
-              std::cout << std::setw(2) << c[i] << " " << evec[c[i]].vbits << " " << std::setw(2) << evec[c[i]].u << " " 
-                        << std::setw(2) << evec[c[i]].v << " " << evec[c[i]].pdgid
-                        << std::fixed << std::setw(10) << std::setprecision(5) << evec[c[i]].w << " " 
-                        << std::fixed << std::setw(10) << std::setprecision(6) << evec[c[i]].edge_pvalue << std::endl;   */
-              ebits.flip(c[i]);                 // Set appropriate bit in the bitset for edge c[i]
-              wsum += evec[c[i]].w;
-              if(evec[c[i]].pdgid==111)npi0++;
-              if(evec[c[i]].pdgid==221)neta++;
-              if(evec[c[i]].pdgid==331)netap++;
+              std::cout << std::setw(2) << c[j] << " " << evec[c[j]].vbits << " " << std::setw(2) << evec[c[j]].u << " " 
+                        << std::setw(2) << evec[c[j]].v << " " << evec[c[]].pdgid
+                        << std::fixed << std::setw(10) << std::setprecision(5) << evec[c[j]].w << " " 
+                        << std::fixed << std::setw(10) << std::setprecision(6) << evec[c[j]].edge_pvalue << std::endl;   */
+              ebits.flip(c[j]);                 // Set appropriate bit in the bitset for edge c[j]
+              wsum += evec[c[j]].w;
+              if(evec[c[j]].pdgid==111)npi0++;
+              if(evec[c[j]].pdgid==221)neta++;
+              if(evec[c[j]].pdgid==331)netap++;
           }
 // Store the CandidateSolution for later perusal
           svec.push_back(CandidateSolution());
diff --git a/Analysis/IsolatedLeptonTagging/src/Utilities.cc b/Analysis/IsolatedLeptonTagging/src/Utilities.cc
index 51d982d..9848fdc 100644
--- a/Analysis/IsolatedLeptonTagging/src/Utilities.cc
+++ b/Analysis/IsolatedLeptonTagging/src/Utilities.cc
@@ -95,7 +95,7 @@ Int_t getOriginalSerial(MCParticle *mcPart, LCCollection *colMCP, Bool_t iHiggs)
   return originalSerial;
 }
 
-Int_t getOriginalSerial(ReconstructedParticle *recPart, LCCollection *colMCTL, LCCollection *colMCP, Bool_t iHiggs) {
+Int_t getOriginalSerial(ReconstructedParticle *recPart, LCCollection *colMCTL, LCCollection *colMCP, Bool_t /*iHiggs*/) {
   // get the serial number of the original particle where the PFO comes from
 
   Int_t originalSerial = -1;
@@ -793,7 +793,7 @@ void listMCParticles(LCCollection *colMC) {
   
 }
 
-  void dumpJetParticles(ReconstructedParticle *jet, LCCollection *colMC, LCCollection *colMCTL) {
+  void dumpJetParticles(ReconstructedParticle *jet, LCCollection */*colMC*/, LCCollection *colMCTL) {
     // list the particles of jets
 
     LCRelationNavigator *navMCTL = new LCRelationNavigator(colMCTL);
@@ -842,7 +842,7 @@ void listMCParticles(LCCollection *colMC) {
 
   // *******************************************************
   // *******************************************************
-  Int_t getVertexComponents(LCCollection *colMC, LCCollection *colMCTL, ReconstructedParticle *vertex, Double_t energyComponents[2], Int_t nparticles[2]) {
+  Int_t getVertexComponents(LCCollection */*colMC*/, LCCollection *colMCTL, ReconstructedParticle *vertex, Double_t energyComponents[2], Int_t nparticles[2]) {
   // calculate energies from signal particles or overlay in a vertex
   // [0]: from signal; [1]: from overlay
 
diff --git a/Analysis/PIDTools/include/LikelihoodPID.hh b/Analysis/PIDTools/include/LikelihoodPID.hh
index dba6d4a..80b72eb 100644
--- a/Analysis/PIDTools/include/LikelihoodPID.hh
+++ b/Analysis/PIDTools/include/LikelihoodPID.hh
@@ -44,7 +44,7 @@ private:
   int Class_electron(TLorentzVector pp, EVENT::Track* trk, EVENT::ClusterVec& cluvec);
   int Class_muon(TLorentzVector pp, EVENT::Track* trk, EVENT::ClusterVec& cluvec);
   int Class_hadron(TLorentzVector pp, EVENT::Track* trk, EVENT::ClusterVec& cluvec);
-  const  double getValue(int type, int valtype,  double value);
+  double getValue(int type, int valtype,  double value);
   double getPenalty(int ptype, int hypothesis,  double p);
   
   double par[5][5]{};
diff --git a/Analysis/PIDTools/include/PIDParticles.hh b/Analysis/PIDTools/include/PIDParticles.hh
index 2c66257..3c879f9 100644
--- a/Analysis/PIDTools/include/PIDParticles.hh
+++ b/Analysis/PIDTools/include/PIDParticles.hh
@@ -80,9 +80,9 @@ static const PIDParticle_base protonProperties("proton", 2212, .938272, BBparsPr
 class LLPIDHypothesis : public PIDParticle_base {
 public:
 
-  LLPIDHypothesis (const char *_name, int _pdg, double _mass,
-               float _prior, const double* _BBpars) :
-    PIDParticle_base(_name, _pdg, _mass, _BBpars),
+  LLPIDHypothesis (const char *name, int pdg_, double mass_,
+               float _prior, const double* BBpars) :
+    PIDParticle_base(name, pdg_, mass_, BBpars),
     prior(_prior), _posterior(0), _logL(0), _threshold(0)
   {  }
 
@@ -118,8 +118,8 @@ private:
 class MVAPIDHypothesis : public PIDParticle_base {
 public:
 
-  MVAPIDHypothesis (const char *_name, int _pdg, double _mass, const double* _BBpars, const float mvaCut=0.) :
-    PIDParticle_base(_name, _pdg, _mass, _BBpars),
+  MVAPIDHypothesis (const char *name_, int pdg_, double mass_, const double* BBpars_, const float mvaCut=0.) :
+    PIDParticle_base(name_, pdg_, mass_, BBpars_),
     _mva(0), _q(0), _sigAbove(0), _mvaCut(mvaCut), _reader(new TMVA::Reader("Silent")),
     _histoQ(NULL), _histoSig(NULL), _histoBkg(NULL)
   {  }
@@ -135,7 +135,7 @@ public:
   float GetMVAout() const { return _mva; }
   float GetQ() const { return _q; }
   float GetSigAbove() const { return _sigAbove; }
-  const float GetMVAcut() const { return _mvaCut; }
+  float GetMVAcut() const { return _mvaCut; }
 
 
   void AddMVAVariable( const TString& name, Float_t* ptr)
diff --git a/Analysis/PIDTools/src/CreatePDFProcessor.cc b/Analysis/PIDTools/src/CreatePDFProcessor.cc
index 6ca6a77..1df416c 100644
--- a/Analysis/PIDTools/src/CreatePDFProcessor.cc
+++ b/Analysis/PIDTools/src/CreatePDFProcessor.cc
@@ -455,10 +455,10 @@ void CreatePDFProcessor::processEvent( LCEvent * evt ) {
     //get deposit energy
     double ecal=0.0,hcal=0.0,mucal=0.0;
     if(cluvec.size()!=0){
-      for(unsigned int i=0;i<cluvec.size();i++){
-	ecal+=cluvec[i]->getSubdetectorEnergies()[0];
-	hcal+=cluvec[i]->getSubdetectorEnergies()[1];
-	mucal+=cluvec[i]->getSubdetectorEnergies()[2];
+      for(unsigned int j=0;j<cluvec.size();j++){
+	ecal+=cluvec[j]->getSubdetectorEnergies()[0];
+	hcal+=cluvec[j]->getSubdetectorEnergies()[1];
+	mucal+=cluvec[j]->getSubdetectorEnergies()[2];
       }
     }
     
diff --git a/Analysis/PIDTools/src/LikelihoodPID.cc b/Analysis/PIDTools/src/LikelihoodPID.cc
index de22e8f..1b7f9a7 100644
--- a/Analysis/PIDTools/src/LikelihoodPID.cc
+++ b/Analysis/PIDTools/src/LikelihoodPID.cc
@@ -412,24 +412,23 @@ double LikelihoodPID::get_dEdxChi2(int parttype, TVector3 p, float hit, double d
 
 double LikelihoodPID::get_dEdxFactor(int parttype, TVector3 p, float hit, double dEdx){
   //get parameters for chi2
-  double tmppar[5],tmpmass=0.0;
-  for(int i=0;i<5;i++) tmppar[i]=par[parttype][i];
+  //double tmpmass=0.0;
   //getmass
   switch(parttype){
   case 0:
-    tmpmass=emass;
+    //tmpmass=emass;
     break;
   case 1:
-    tmpmass=mmass;
+    //tmpmass=mmass;
     break;
   case 2:
-    tmpmass=pimass;
+    //tmpmass=pimass;
     break;
   case 3:
-    tmpmass=kmass;
+    //tmpmass=kmass;
     break;
   case 4:
-    tmpmass=pmass;
+    //tmpmass=pmass;
     break;
   }
 
@@ -458,7 +457,7 @@ double LikelihoodPID::get_dEdxDist(int parttype){
   return dedxdist;
 }
 
-double LikelihoodPID::get_Norm(double dedx, float hit, double trkcos){
+double LikelihoodPID::get_Norm(double dedx, float /*hit*/, double trkcos){
   //cal. hit dep.
   double f1=1.0;   //1.0+TMath::Exp(-hit/1.468);   //already corrected
   //cal. polar angle dep.
@@ -1056,7 +1055,7 @@ int LikelihoodPID::Class_hadron(TLorentzVector pp, EVENT::Track* trk, EVENT::Clu
   return okflg;  
 }
 
-const double LikelihoodPID::getValue(int type, int valtype, double value){
+double LikelihoodPID::getValue(int type, int valtype, double value){
 
   /*int nbins=pdf[type][valtype]->GetNbinsX();
   double interval=pdf[type][valtype]->GetBinWidth(1);
@@ -1124,153 +1123,153 @@ const double LikelihoodPID::getValue(int type, int valtype, double value){
 }
 
 double LikelihoodPID::getPenalty(int ptype, int hypothesis, double p){
-  double par[3]={0.0,0.0,0.0};
+  double par_[3]={0.0,0.0,0.0};
   //set parameters
   switch(ptype){
   case 0:  //electron
     if(hypothesis==0){
-      par[0]=0.0;
-      par[1]=1.0;
-      par[2]=1.00178;
+      par_[0]=0.0;
+      par_[1]=1.0;
+      par_[2]=1.00178;
 
     }else if(hypothesis==1){
-      par[0]=0.101945;
-      par[1]=2.18719;
-      par[2]=0.990000;
+      par_[0]=0.101945;
+      par_[1]=2.18719;
+      par_[2]=0.990000;
 
     }else if(hypothesis==2){
-      par[0]=0.104521;
-      par[1]=1.98490;
-      par[2]=0.990000;
+      par_[0]=0.104521;
+      par_[1]=1.98490;
+      par_[2]=0.990000;
 
     }else if(hypothesis==3){
-      par[0]=0.234299;
-      par[1]=0.276835;
-      par[2]=0.965973;
+      par_[0]=0.234299;
+      par_[1]=0.276835;
+      par_[2]=0.965973;
 
     }else{
-      par[0]=0.414613;
-      par[1]=-0.132530;
-      par[2]=0.949679;
+      par_[0]=0.414613;
+      par_[1]=-0.132530;
+      par_[2]=0.949679;
 
     }
 
     break;
   case 1:   //muon
     if(hypothesis==0){
-      par[0]=-0.00512190;
-      par[1]=-0.211835;
-      par[2]=1.00024;
+      par_[0]=-0.00512190;
+      par_[1]=-0.211835;
+      par_[2]=1.00024;
 
     }else if(hypothesis==1){
-      par[0]=0.0;
-      par[1]=1.00;
-      par[2]=0.999684;
+      par_[0]=0.0;
+      par_[1]=1.00;
+      par_[2]=0.999684;
 
     }else if(hypothesis==2){
-      par[0]=0.00833283;
-      par[1]=9.99995;
-      par[2]=0.999027;
+      par_[0]=0.00833283;
+      par_[1]=9.99995;
+      par_[2]=0.999027;
 
     }else if(hypothesis==3){
-      par[0]=0.0964021;
-      par[1]=-0.214469;
-      par[2]=0.989688;
+      par_[0]=0.0964021;
+      par_[1]=-0.214469;
+      par_[2]=0.989688;
 
     }else{
-      par[0]=0.318674;
-      par[1]=-0.197755;
-      par[2]=0.968436;
+      par_[0]=0.318674;
+      par_[1]=-0.197755;
+      par_[2]=0.968436;
     }
 
     break;
   case 2:   //pion
     if(hypothesis==0){
-      par[0]=-0.0123577;
-      par[1]=-0.141521;
-      par[2]=1.00273;
+      par_[0]=-0.0123577;
+      par_[1]=-0.141521;
+      par_[2]=1.00273;
 
     }else if(hypothesis==1){
-      par[0]=-0.00558462;
-      par[1]=-0.136941;
-      par[2]=1.00135;
+      par_[0]=-0.00558462;
+      par_[1]=-0.136941;
+      par_[2]=1.00135;
 
     }else if(hypothesis==2){
-      par[0]=0.0;
-      par[1]=1.0;
-      par[2]=1.00001;
+      par_[0]=0.0;
+      par_[1]=1.0;
+      par_[2]=1.00001;
 
     }else if(hypothesis==3){
-      par[0]=0.122083;
-      par[1]=-0.1333923;
-      par[2]=0.976863;
+      par_[0]=0.122083;
+      par_[1]=-0.1333923;
+      par_[2]=0.976863;
 
     }else{
-      par[0]=0.401111;
-      par[1]=-0.116807;
-      par[2]=0.930906;
+      par_[0]=0.401111;
+      par_[1]=-0.116807;
+      par_[2]=0.930906;
     }
 
     break;
   case 3:    //kaon
     if(hypothesis==0){
-      par[0]=-0.102300;
-      par[1]=-0.139570;
-      par[2]=1.01362;
+      par_[0]=-0.102300;
+      par_[1]=-0.139570;
+      par_[2]=1.01362;
 
     }else if(hypothesis==1){
-      par[0]=-0.0973257;
-      par[1]=-0.138932;
-      par[2]=1.01293;
+      par_[0]=-0.0973257;
+      par_[1]=-0.138932;
+      par_[2]=1.01293;
 
     }else if(hypothesis==2){
-      par[0]=-0.0936450;
-      par[1]=-0.138469;
-      par[2]=1.01242;
+      par_[0]=-0.0936450;
+      par_[1]=-0.138469;
+      par_[2]=1.01242;
 
     }else if(hypothesis==3){
-      par[0]=0.0;
-      par[1]=1.0;
-      par[2]=0.999865;
+      par_[0]=0.0;
+      par_[1]=1.0;
+      par_[2]=0.999865;
 
     }else{
-      par[0]=0.223317;
-      par[1]=-0.101273;
-      par[2]=0.973484;
+      par_[0]=0.223317;
+      par_[1]=-0.101273;
+      par_[2]=0.973484;
     }
 
     break;
   case 4:   //proton
     if(hypothesis==0){
-      par[0]=-0.260150;
-      par[1]=-0.0990612;
-      par[2]=1.02854;
+      par_[0]=-0.260150;
+      par_[1]=-0.0990612;
+      par_[2]=1.02854;
 
     }else if(hypothesis==1){
-      par[0]=-0.256503;
-      par[1]=-0.0976728;
-      par[2]=1.02811;
+      par_[0]=-0.256503;
+      par_[1]=-0.0976728;
+      par_[2]=1.02811;
 
     }else if(hypothesis==2){
-      par[0]=-0.253788;
-      par[1]=-0.0966732;
-      par[2]=1.02779;
+      par_[0]=-0.253788;
+      par_[1]=-0.0966732;
+      par_[2]=1.02779;
 
     }else if(hypothesis==3){
-      par[0]=-0.183031;
-      par[1]=-0.0742123;
-      par[2]=1.01965;
+      par_[0]=-0.183031;
+      par_[1]=-0.0742123;
+      par_[2]=1.01965;
 
     }else{
-      par[0]=0.0;
-      par[1]=1.0;
-      par[2]=0.999791;
+      par_[0]=0.0;
+      par_[1]=1.0;
+      par_[2]=0.999791;
     }
 
     break;
   }
 
-  return par[0]/sqrt(p*p+par[1])+par[2]; 
+  return par_[0]/sqrt(p*p+par_[1])+par_[2]; 
 }
 
 void LikelihoodPID::CalculateDeltaPosition(float charge, TVector3 p, const float* calpos){
diff --git a/Analysis/PIDTools/src/LowMomentumMuPiSeparationPID_BDTG.cc b/Analysis/PIDTools/src/LowMomentumMuPiSeparationPID_BDTG.cc
index 39e49ad..8fbe3fb 100644
--- a/Analysis/PIDTools/src/LowMomentumMuPiSeparationPID_BDTG.cc
+++ b/Analysis/PIDTools/src/LowMomentumMuPiSeparationPID_BDTG.cc
@@ -141,12 +141,8 @@ Int_t LowMomentumMuPiSeparationPID_BDTG::MuPiSeparation(TLorentzVector pp, EVENT
    float clpox=0;
    float clpoy=0;
    float clpoz=0;
-   float chene[10000]={0};
    float chpox[10000]={0};
    float chpoy[10000]={0};
-   float chpoz[10000]={0};
-
-   int nhit=0;
 
   float Rhits_clu = 0;
   float Rhits2_clu = 0;
@@ -157,8 +153,6 @@ Int_t LowMomentumMuPiSeparationPID_BDTG::MuPiSeparation(TLorentzVector pp, EVENT
   float cosalphacluster=0;
   unsigned nch=0;
  
-  const EVENT::TrackStateVec & tss = trk->getTrackStates() ;
-  
   const lcio::TrackState* ts ;
   
   ts = trk->getTrackState( lcio::TrackState::AtCalorimeter )  ;
@@ -167,7 +161,7 @@ Int_t LowMomentumMuPiSeparationPID_BDTG::MuPiSeparation(TLorentzVector pp, EVENT
   float tscpy = ts->getReferencePoint()[1] ;
   float tscpz = ts->getReferencePoint()[2] ;
   
-  for(int iclu=0; iclu < cluvec.size(); iclu++){
+  for(size_t iclu=0; iclu < cluvec.size(); iclu++){
       
       float Eclu=0;
       if(cluvec[iclu]->getEnergy() > Eclu){
@@ -181,15 +175,12 @@ Int_t LowMomentumMuPiSeparationPID_BDTG::MuPiSeparation(TLorentzVector pp, EVENT
           
           nch =tempvec.size();
           for( unsigned jhit=0; jhit < nch ; ++jhit ) {
-              nhit = tempvec.size();
-              chene[jhit] =  tempvec[jhit]->getEnergy();
               chpox[jhit] =  tempvec[jhit]->getPosition()[0];
               chpoy[jhit] =  tempvec[jhit]->getPosition()[1];
-              chpoz[jhit] =  tempvec[jhit]->getPosition()[2];
           }
       }
   }
-  for(int iclu=0; iclu < cluvec.size(); iclu++){
+  for(size_t iclu=0; iclu < cluvec.size(); iclu++){
       for( unsigned jhit=0; jhit < nch ; ++jhit ) {
           
           Rhits_clu=sqrt(pow(chpox[jhit]-clpox,2)+pow(chpoy[jhit]-clpoy,2));
diff --git a/Analysis/PIDTools/src/PIDVariables.cc b/Analysis/PIDTools/src/PIDVariables.cc
index 439a12f..2b060b9 100644
--- a/Analysis/PIDTools/src/PIDVariables.cc
+++ b/Analysis/PIDTools/src/PIDVariables.cc
@@ -43,7 +43,7 @@ PID_CaloTotal::PID_CaloTotal() :
     PIDVariable_base("CaloTotal", "(ECAL+HCAL)/p", "")
 {}
 
-int PID_CaloTotal::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CaloTotal::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 p3)
 {
   float p = p3.Mag();
   if(p < pCut) {
@@ -77,7 +77,7 @@ PID_CaloEFrac::PID_CaloEFrac() :
     PIDVariable_base("CaloEFrac", "ECAL/(ECAL+HCAL)", "")
 {}
 
-int PID_CaloEFrac::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CaloEFrac::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   float ecal=0., hcal=0.;
   if(cluvec.size()>0){
@@ -112,7 +112,7 @@ PID_CaloMuSys::PID_CaloMuSys() :
     PIDVariable_base("CaloMuSys", "E_{#mu system}", "GeV")
 {}
 
-int PID_CaloMuSys::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CaloMuSys::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   float mucal=0.;
   if(cluvec.size()>0){
@@ -141,7 +141,7 @@ PID_CluShapeChi2::PID_CluShapeChi2() :
     PIDVariable_base("CluShapeChi2", "Cluster shape #chi^{2}", "")
 {}
 
-int PID_CluShapeChi2::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CluShapeChi2::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   if (cluvec.size() < 1) {
     SetOutOfRange();
@@ -168,7 +168,7 @@ PID_CluShapeLDiscr::PID_CluShapeLDiscr() :
     PIDVariable_base("DiscrepancyL", "d_{Shower max} / d_{EM shower max}", "")
 {}
 
-int PID_CluShapeLDiscr::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CluShapeLDiscr::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   if (cluvec.size() < 1) {
     SetOutOfRange();
@@ -190,7 +190,7 @@ PID_CluShapeTDiscr::PID_CluShapeTDiscr() :
     PIDVariable_base("DiscrepancyT", "Absorption length", "R_{m}")
 {}
 
-int PID_CluShapeTDiscr::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CluShapeTDiscr::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   if (cluvec.size() < 1) {
     SetOutOfRange();
@@ -212,7 +212,7 @@ PID_CluShapeXl20::PID_CluShapeXl20() :
     PIDVariable_base("Xl20", "xl20", "?")
 {}
 
-int PID_CluShapeXl20::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec trax, const TVector3 p3)
+int PID_CluShapeXl20::Update(const EVENT::ClusterVec cluvec, const EVENT::TrackVec /*trax*/, const TVector3 /*p3*/)
 {
   if (cluvec.size() < 1) {
     SetOutOfRange();
@@ -249,7 +249,7 @@ PID_dEdxChi2::~PID_dEdxChi2()
   delete _hypothesis;
 }
 
-int PID_dEdxChi2::Update(const EVENT::ClusterVec cluvec,
+int PID_dEdxChi2::Update(const EVENT::ClusterVec /*cluvec*/,
     const EVENT::TrackVec trax, const TVector3 p3)
 {
   int result = 0;
@@ -291,7 +291,7 @@ PID_dEdxLogChi2::~PID_dEdxLogChi2()
   delete _hypothesis;
 }
 
-int PID_dEdxLogChi2::Update(const EVENT::ClusterVec cluvec,
+int PID_dEdxLogChi2::Update(const EVENT::ClusterVec /*cluvec*/,
     const EVENT::TrackVec trax, const TVector3 p3)
 {
   int result = 0;
@@ -331,7 +331,7 @@ PIDVariables_base::PIDVariables_base() :
   _p(0.)
 {}
 
-PIDVariables_base::PIDVariables_base(EVENT::ReconstructedParticle* particle) :
+PIDVariables_base::PIDVariables_base(EVENT::ReconstructedParticle* /*particle*/) :
   _p(0.)
 {}
 
diff --git a/Analysis/RecoMCTruthLink/src/MCTruthJetEnergy.cc b/Analysis/RecoMCTruthLink/src/MCTruthJetEnergy.cc
index 70a1dc2..9c1da93 100644
--- a/Analysis/RecoMCTruthLink/src/MCTruthJetEnergy.cc
+++ b/Analysis/RecoMCTruthLink/src/MCTruthJetEnergy.cc
@@ -112,7 +112,7 @@ void MCTruthJetEnergy::processEvent( LCEvent * evt ) {
       jetcol = evt->getCollection( _jetcolNames[i] ) ;
     }
     
-    catch( lcio::DataNotAvailableException ){
+    catch( const lcio::DataNotAvailableException& ){
       
       streamlog_out( WARNING ) << " collection " << _jetcolNames[i] << "  not found ! " << std::endl ;
       
@@ -232,7 +232,7 @@ void MCTruthJetEnergy::check( LCEvent * evt ) {
       jetcol = evt->getCollection( _jetcolNames[i] ) ;
     }
     
-    catch( lcio::DataNotAvailableException ){
+    catch( const lcio::DataNotAvailableException& ){
       
       streamlog_out( WARNING ) << " collection " << _jetcolNames[i] << "  not found ! " << std::endl ;
       
diff --git a/Analysis/RecoMCTruthLink/src/QuarkJetPairing.cc b/Analysis/RecoMCTruthLink/src/QuarkJetPairing.cc
index b08172b..c7f79a5 100644
--- a/Analysis/RecoMCTruthLink/src/QuarkJetPairing.cc
+++ b/Analysis/RecoMCTruthLink/src/QuarkJetPairing.cc
@@ -108,43 +108,43 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
 
   float energy = 0;
  
-  float jet_ene[4];
-  float quark_ene[4];
+  //float jet_ene[4];
+  float quark_ene_[4];
      
   float jet_theta[4];
   float quark_theta[4]; 
      
-  float  jet_px[4];
-  float quark_px[4];
+  float  jet_px_[4];
+  float quark_px_[4];
      
-  float  jet_py[4];
-  float quark_py[4]; 
+  float  jet_py_[4];
+  float quark_py_[4]; 
      
-  float jet_pz[4];
-  float quark_pz[4];
+  float jet_pz_[4];
+  float quark_pz_[4];
      
-  float jet_ptot[4];
-  float quark_ptot[4];
+  float jet_ptot_[4];
+  float quark_ptot_[4];
      
   int quark[4][24]; 
   int jet[4][24]; 
      
   for(int i=0; i<4; i++){
        
-    jet_ene[i]=0;
-    quark_ene[i]=0;
+    //jet_ene[i]=0;
+    quark_ene_[i]=0;
        
     jet_theta[i]=0;
     quark_theta[i]=0;
        
-    jet_px[i]=0;
-    quark_px[i]=0;
-    jet_py[i]=0;
-    quark_py[i]=0;
-    jet_pz[i]=0;
-    quark_pz[i]=0;
-    jet_ptot[i]=0;
-    quark_ptot[i]=0;
+    jet_px_[i]=0;
+    quark_px_[i]=0;
+    jet_py_[i]=0;
+    quark_py_[i]=0;
+    jet_pz_[i]=0;
+    quark_pz_[i]=0;
+    jet_ptot_[i]=0;
+    quark_ptot_[i]=0;
   } 
 
      
@@ -155,24 +155,24 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
    
   if (jetcol != 0) {
        
-    int nJETS = jetcol->getNumberOfElements()  ;
+    int nJETS_ = jetcol->getNumberOfElements()  ;
        
-    if (nJETS != 4) return; 
+    if (nJETS_ != 4) return; 
 
-    for(int i=0; i< nJETS ; i++){
+    for(int i=0; i< nJETS_ ; i++){
          
  
       ReconstructedParticle* j = dynamic_cast<ReconstructedParticle*>( jetcol->getElementAt( i ) ) ;
                
       if (j) {
 	    
-	jet_px[i]=j->getMomentum()[0]; 
-	jet_py[i]=j->getMomentum()[1];
-	jet_pz[i]=j->getMomentum()[2];
-	jet_ene[i]=j->getEnergy();
+	jet_px_[i]=j->getMomentum()[0]; 
+	jet_py_[i]=j->getMomentum()[1];
+	jet_pz_[i]=j->getMomentum()[2];
+	//jet_ene[i]=j->getEnergy();
  	    
       }  
-      jet_ptot[i]=sqrt(pow(jet_px[i], 2)+pow(jet_py[i], 2)+pow(jet_pz[i], 2));
+      jet_ptot_[i]=sqrt(pow(jet_px_[i], 2)+pow(jet_py_[i], 2)+pow(jet_pz_[i], 2));
     }
   }  
 
@@ -187,12 +187,12 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
                
       if (q) {
 	    
-  	quark_px[e-6]=q->getMomentum()[0];
-  	quark_py[e-6]=q->getMomentum()[1];
-  	quark_pz[e-6]=q->getMomentum()[2];
-  	quark_ene[e-6]=q->getEnergy();
+  	quark_px_[e-6]=q->getMomentum()[0];
+  	quark_py_[e-6]=q->getMomentum()[1];
+  	quark_pz_[e-6]=q->getMomentum()[2];
+  	quark_ene_[e-6]=q->getEnergy();
       }
-      quark_ptot[e-6]=sqrt(pow(quark_px[e-6], 2)+pow(quark_py[e-6], 2)+pow(quark_pz[e-6], 2));
+      quark_ptot_[e-6]=sqrt(pow(quark_px_[e-6], 2)+pow(quark_py_[e-6], 2)+pow(quark_pz_[e-6], 2));
     } 
   }
       
@@ -203,8 +203,6 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
  
   int counter_jets = 0; 
    
-  Float_t theta[4];
-  
   Float_t alpha[24];
   Float_t alpha_min = 9999; 
   int iperm_min = 0; 
@@ -212,7 +210,7 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
   //////////////////////////////////////////permutation algorithm///////////////////////////////////////////
  
   for(int i=0; i<4; i++){
-    energy+=quark_ene[i];
+    energy+=quark_ene_[i];
   }
  
     if(energy >495){
@@ -245,7 +243,7 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
       for(int n = 0; n < iperm; n++){
 	alpha[n] = 0;
 	for (int ijet=0; ijet<4; ijet++) { 
-	  alpha[n]+= acos(((jet_px[jet[ijet][n]]*quark_px[quark[ijet][n]])+(jet_py[jet[ijet][n]]*quark_py[quark[ijet][n]])+(jet_pz[jet[ijet][n]]*quark_pz[quark[ijet][n]]))/(jet_ptot[jet[ijet][n]]*quark_ptot[quark[ijet][n]]));
+	  alpha[n]+= acos(((jet_px_[jet[ijet][n]]*quark_px_[quark[ijet][n]])+(jet_py_[jet[ijet][n]]*quark_py_[quark[ijet][n]])+(jet_pz_[jet[ijet][n]]*quark_pz_[quark[ijet][n]]))/(jet_ptot_[jet[ijet][n]]*quark_ptot_[quark[ijet][n]]));
 	}
 	if(alpha[n] < alpha_min){
 	  alpha_min = alpha[n];
@@ -263,9 +261,8 @@ void QuarkJetPairing::processEvent( LCEvent * evt ) {
 	
 	  //////////////////////////////////////////// Determination of theta //////////////////////////
 	
-	  theta[ijet]=0;
-	  quark_theta[ijet] = atan((sqrt((pow(quark_px[quark[ijet][iperm_min]],2))+(pow(quark_py[quark[ijet][iperm_min]],2))))/quark_pz[quark[ijet][iperm_min]]);
-	  jet_theta[ijet] = atan((sqrt((pow(jet_px[jet[ijet][iperm_min]],2))+(pow(jet_py[jet[ijet][iperm_min]],2))))/jet_pz[jet[ijet][iperm_min]]);
+	  quark_theta[ijet] = atan((sqrt((pow(quark_px_[quark[ijet][iperm_min]],2))+(pow(quark_py_[quark[ijet][iperm_min]],2))))/quark_pz_[quark[ijet][iperm_min]]);
+	  jet_theta[ijet] = atan((sqrt((pow(jet_px_[jet[ijet][iperm_min]],2))+(pow(jet_py_[jet[ijet][iperm_min]],2))))/jet_pz_[jet[ijet][iperm_min]]);
 	  if(quark_theta[ijet] < 0){
 	    quark_theta[ijet] = M_PI+quark_theta[ijet];	
 	  }
diff --git a/Analysis/RecoMCTruthLink/src/RecoMCTruthLinker.cc b/Analysis/RecoMCTruthLink/src/RecoMCTruthLinker.cc
index 2e43dd2..3128150 100644
--- a/Analysis/RecoMCTruthLink/src/RecoMCTruthLinker.cc
+++ b/Analysis/RecoMCTruthLink/src/RecoMCTruthLinker.cc
@@ -439,7 +439,7 @@ void RecoMCTruthLinker::processEvent( LCEvent * evt ) {
 
   
 }
-void RecoMCTruthLinker::trackLinker(   LCEvent * evt, LCCollection* mcpCol ,  LCCollection* trackCol,  
+void RecoMCTruthLinker::trackLinker(   LCEvent * evt, LCCollection* /*mcpCol*/ ,  LCCollection* trackCol,  
                                        LCCollection** ttrlcol,  LCCollection** trtlcol) { 
 
 
@@ -473,8 +473,6 @@ void RecoMCTruthLinker::trackLinker(   LCEvent * evt, LCCollection* mcpCol ,  LC
   // loop over reconstructed tracks
   int nTrack = trackCol->getNumberOfElements() ;
   
-  int ifoundch =0;
-  
   streamlog_out( DEBUG6 ) << " *** Sorting out Track<->MCParticle using simHit<->MCParticle." << std::endl;
 
   for(int i=0;i<nTrack;++i){
@@ -621,8 +619,6 @@ void RecoMCTruthLinker::trackLinker(   LCEvent * evt, LCCollection* mcpCol ,  LC
       
     
     }
-    
-    ifoundch=ifound;
   } 
   //  seen-true relation complete. add the collection
 
@@ -944,7 +940,6 @@ void RecoMCTruthLinker::clusterLinker(  LCEvent * evt,  LCCollection* mcpCol ,
                     
 
                     int starts_in_tracker = 0 ;
-                    unsigned lll=0 ;
                     int has_pi0 = 0 ;
                     int oma_in_calo = 0;
                     double rdist =0.;
@@ -960,11 +955,9 @@ void RecoMCTruthLinker::clusterLinker(  LCEvent * evt,  LCCollection* mcpCol ,
                                                                                                     // take place (think delta-rays !)
  		      if ( sister->isBackscatter()) {
                         has_bs = 1 ; 
-                        lll=kkk;
                         break ;
 		      } else if ( sister->isDecayedInTracker() ) {
                         starts_in_tracker = 1 ;
-                        lll=kkk;
                         break ;
                       }
                       // any pi0:s at all ? (it doesn't matter that we break at the two cases above, 
@@ -1108,7 +1101,6 @@ void RecoMCTruthLinker::clusterLinker(  LCEvent * evt,  LCCollection* mcpCol ,
   
   std::vector<Cluster*> missingMC ;
   missingMC.reserve( nCluster ) ;
-  int ifoundclu =0;
   // now for the clusters
   
   
@@ -1486,7 +1478,6 @@ void RecoMCTruthLinker::clusterLinker(  LCEvent * evt,  LCCollection* mcpCol ,
       truthClusterRelNav.addRelation(   theMCPs[iii] , clu , weight ) ;
       
     }
-    ifoundclu=ifound;
   } // cluster loop
   
   streamlog_out( DEBUG6 ) << " *** Sorting out Cluster<->MCParticle : DONE" << std::endl;
@@ -2064,7 +2055,7 @@ void RecoMCTruthLinker::check( LCEvent * evt ) {
   try{  
     mcpskCol = evt->getCollection( _mcParticlesSkimmedName ); 
   }
-  catch (DataNotAvailableException e){
+  catch (const DataNotAvailableException& e){
     streamlog_out(DEBUG9) << "RecoMCTructh::Check(): MCParticleSkimmed collection \"" << _mcParticlesSkimmedName << "\" does not exist, skipping" << std::endl;
   }
   
@@ -2183,24 +2174,24 @@ void RecoMCTruthLinker::mergeTrackerHitRelations(LCEvent * evt){
  
       StringVec stringKeys ;
       col->getParameters().getStringKeys( stringKeys ) ;
-      for(unsigned i=0; i< stringKeys.size() ; i++ ){
+      for(unsigned j=0; j< stringKeys.size() ; j++ ){
         StringVec vals ;
-        col->getParameters().getStringVals(  stringKeys[i] , vals ) ;
-        _mergedTrackerHitRelCol->parameters().setValues(  stringKeys[i] , vals ) ;   
+        col->getParameters().getStringVals(  stringKeys[j] , vals ) ;
+        _mergedTrackerHitRelCol->parameters().setValues(  stringKeys[j] , vals ) ;   
       }
       StringVec intKeys ;
       col->getParameters().getIntKeys( intKeys ) ;
-      for(unsigned i=0; i< intKeys.size() ; i++ ){
+      for(unsigned j=0; j< intKeys.size() ; j++ ){
         IntVec vals ;
-        col->getParameters().getIntVals(  intKeys[i] , vals ) ;
-        _mergedTrackerHitRelCol->parameters().setValues(  intKeys[i] , vals ) ;   
+        col->getParameters().getIntVals(  intKeys[j] , vals ) ;
+        _mergedTrackerHitRelCol->parameters().setValues(  intKeys[j] , vals ) ;   
       }
       StringVec floatKeys ;
       col->getParameters().getFloatKeys( floatKeys ) ;
-      for(unsigned i=0; i< floatKeys.size() ; i++ ){
+      for(unsigned j=0; j< floatKeys.size() ; j++ ){
         FloatVec vals ;
-        col->getParameters().getFloatVals(  floatKeys[i] , vals ) ;
-        _mergedTrackerHitRelCol->parameters().setValues(  floatKeys[i] , vals ) ;   
+        col->getParameters().getFloatVals(  floatKeys[j] , vals ) ;
+        _mergedTrackerHitRelCol->parameters().setValues(  floatKeys[j] , vals ) ;   
       }
 
       
@@ -2269,24 +2260,24 @@ void RecoMCTruthLinker::mergeCaloHitRelations(LCEvent * evt){
  
       StringVec stringKeys ;
       col->getParameters().getStringKeys( stringKeys ) ;
-      for(unsigned i=0; i< stringKeys.size() ; i++ ){
+      for(unsigned j=0; j< stringKeys.size() ; j++ ){
         StringVec vals ;
-        col->getParameters().getStringVals(  stringKeys[i] , vals ) ;
-        _mergedCaloHitRelCol->parameters().setValues(  stringKeys[i] , vals ) ;   
+        col->getParameters().getStringVals(  stringKeys[j] , vals ) ;
+        _mergedCaloHitRelCol->parameters().setValues(  stringKeys[j] , vals ) ;   
       }
       StringVec intKeys ;
       col->getParameters().getIntKeys( intKeys ) ;
-      for(unsigned i=0; i< intKeys.size() ; i++ ){
+      for(unsigned j=0; j< intKeys.size() ; j++ ){
         IntVec vals ;
-        col->getParameters().getIntVals(  intKeys[i] , vals ) ;
-        _mergedCaloHitRelCol->parameters().setValues(  intKeys[i] , vals ) ;   
+        col->getParameters().getIntVals(  intKeys[j] , vals ) ;
+        _mergedCaloHitRelCol->parameters().setValues(  intKeys[j] , vals ) ;   
       }
       StringVec floatKeys ;
       col->getParameters().getFloatKeys( floatKeys ) ;
-      for(unsigned i=0; i< floatKeys.size() ; i++ ){
+      for(unsigned j=0; j< floatKeys.size() ; j++ ){
         FloatVec vals ;
-        col->getParameters().getFloatVals(  floatKeys[i] , vals ) ;
-        _mergedCaloHitRelCol->parameters().setValues(  floatKeys[i] , vals ) ;   
+        col->getParameters().getFloatVals(  floatKeys[j] , vals ) ;
+        _mergedCaloHitRelCol->parameters().setValues(  floatKeys[j] , vals ) ;   
       }
 
       
diff --git a/Analysis/TauFinder/src/EvaluateTauFinder.cc b/Analysis/TauFinder/src/EvaluateTauFinder.cc
index dc3b0c8..fa00d68 100644
--- a/Analysis/TauFinder/src/EvaluateTauFinder.cc
+++ b/Analysis/TauFinder/src/EvaluateTauFinder.cc
@@ -142,25 +142,25 @@ void EvaluateTauFinder::processEvent( LCEvent * evt )
   LCCollection *colTauRecLink;
   try {
     colMC = evt->getCollection( _colNameMC ) ;
-  } catch (Exception e) {
+  } catch (const Exception& e) {
     colMC = 0;
   }
   
   try {
     colTau = evt->getCollection( _incol ) ;
-  } catch (Exception e) {
+  } catch (const Exception&) {
     colTau = 0;
   }
   
   try {
     colMCTruth = evt->getCollection( _colNameMCTruth ) ;
-  } catch (Exception e) {
+  } catch (const Exception&) {
     colMCTruth = 0;
   }
  
   try {
     colTauRecLink = evt->getCollection( _colNameTauRecLink ) ;
-  } catch (Exception e) {
+  } catch (const Exception&) {
     colTauRecLink = 0;
   }
   
diff --git a/Analysis/TauFinder/src/PrepareRECParticles.cc b/Analysis/TauFinder/src/PrepareRECParticles.cc
index 2ce7b7d..433fe9d 100644
--- a/Analysis/TauFinder/src/PrepareRECParticles.cc
+++ b/Analysis/TauFinder/src/PrepareRECParticles.cc
@@ -129,13 +129,13 @@ void PrepareRECParticles::processEvent( LCEvent * evt )
   LCCollection *colMC, *colTrack;
   try {
     colMC = evt->getCollection( _colNameMC ) ;
-  } catch (Exception e) {
+  } catch (const Exception& e) {
     colMC = 0;
   }
   
   try {
     colTrack = evt->getCollection( _colNameTrack ) ;
-  } catch (Exception e) {
+  } catch (const Exception& e) {
     colTrack = 0;
   }
   
diff --git a/Analysis/TauFinder/src/TauFinder.cc b/Analysis/TauFinder/src/TauFinder.cc
index 2a5f579..cbe8bcd 100644
--- a/Analysis/TauFinder/src/TauFinder.cc
+++ b/Analysis/TauFinder/src/TauFinder.cc
@@ -157,7 +157,7 @@ void TauFinder::processEvent( LCEvent * evt )
 
   try {
     colRECO = evt->getCollection( _incol ) ;
-  } catch (Exception e) {
+  } catch (const Exception& e) {
     colRECO = 0;
   }
  
diff --git a/Analysis/TrueJet/src/TrueJet.cc b/Analysis/TrueJet/src/TrueJet.cc
index 7e26404..4e3b324 100644
--- a/Analysis/TrueJet/src/TrueJet.cc
+++ b/Analysis/TrueJet/src/TrueJet.cc
@@ -148,7 +148,7 @@ void TrueJet::processEvent( LCEvent * event ) {
     try{
         mcpcol = evt->getCollection( _MCParticleColllectionName );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _MCParticleColllectionName  << " collection not available" << std::endl;
         mcpcol = NULL;
@@ -157,7 +157,7 @@ void TrueJet::processEvent( LCEvent * event ) {
     try{
         rmclcol = evt->getCollection( _recoMCTruthLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) << _recoMCTruthLink   << " collection not available" << std::endl;
         rmclcol = NULL;
diff --git a/Analysis/TrueJet_Parser/src/TrueJet_Parser.cc b/Analysis/TrueJet_Parser/src/TrueJet_Parser.cc
index 1f03080..d7b2f05 100644
--- a/Analysis/TrueJet_Parser/src/TrueJet_Parser.cc
+++ b/Analysis/TrueJet_Parser/src/TrueJet_Parser.cc
@@ -64,12 +64,12 @@ double TrueJet_Parser::Etrue(int ijet) {
   return E;
 }
 double TrueJet_Parser::Mtrue(int ijet) {
-  const double* p4 = p4true(ijet);
+  const double* p4_ = p4true(ijet);
   double psqr=0;
   for (int kk=1 ; kk<=3 ; kk++ ) {
-     psqr+=p4[kk]*p4[kk];
+     psqr+=p4_[kk]*p4_[kk];
   }
-  double M=sqrt(p4[0]*p4[0]-psqr);
+  double M=sqrt(p4_[0]*p4_[0]-psqr);
   return M ;
 }
 const double* TrueJet_Parser::ptrue(int ijet) {
@@ -83,15 +83,15 @@ const double* TrueJet_Parser::ptrue(int ijet) {
     if ( _COUNT_FSR ) {
       if (  abs(www[kk]) == 1.0) {
         const double* mom = mcp->getMomentum();
-        for (int kk=0 ; kk<3 ; kk++ ) {
-          p3[kk]+=mom[kk];
+        for (int ll=0 ; ll<3 ; ll++ ) {
+          p3[ll]+=mom[ll];
         }
       }
     } else {
       if (  www[kk] == 1.0) {
         const double* mom = mcp->getMomentum();
-        for (int kk=0 ; kk<3 ; kk++ ) {
-          p3[kk]+=mom[kk];
+        for (int ll=0 ; ll<3 ; ll++ ) {
+          p3[ll]+=mom[ll];
         }
       }
     }
@@ -135,7 +135,7 @@ double TrueJet_Parser::Etrueseen(int ijet) {
     try{
      rmclcol = evt->getCollection( get_recoMCTruthLink() );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
       streamlog_out(WARNING) << get_recoMCTruthLink()   << " collection not available" << std::endl;
         rmclcol = NULL;
@@ -154,10 +154,10 @@ double TrueJet_Parser::Etrueseen(int ijet) {
   return E;
 }
 double TrueJet_Parser::Mtrueseen(int ijet) {
-  const double* p4 = p4trueseen(ijet);
+  const double* p4_ = p4trueseen(ijet);
   double psqr=0;
   for (int kk=1 ; kk<=3 ; kk++ ) {
-     psqr+=p4[kk]*p4[kk];
+     psqr+=p4_[kk]*p4_[kk];
   }
   double M=sqrt(p4[0]*p4[0]-psqr);
   return M ;
@@ -168,7 +168,7 @@ const double* TrueJet_Parser::ptrueseen(int ijet) {
      try{
       rmclcol = evt->getCollection( get_recoMCTruthLink() );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
       streamlog_out(WARNING) << get_recoMCTruthLink()   << " collection not available" << std::endl;
         rmclcol = NULL;
@@ -183,8 +183,8 @@ const double* TrueJet_Parser::ptrueseen(int ijet) {
     LCObjectVec recovec = reltrue_tj->getRelatedFromObjects( mcp);
     if ( recovec.size() > 0 ) { // if reconstructed
       const double* mom = mcp->getMomentum();
-      for (int kk=0 ; kk<3 ; kk++ ) {
-        p3[kk]+=mom[kk];
+      for (int ll=0 ; ll<3 ; ll++ ) {
+        p3[ll]+=mom[ll];
       }
     }
   }
@@ -467,7 +467,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       tjcol = evt->getCollection( _trueJetCollectionName);
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
       streamlog_out(WARNING) <<    _trueJetCollectionName  << " collection not available 1" << std::endl;
       tjcol = NULL;
@@ -479,7 +479,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       fcncol = evt->getCollection( _finalColourNeutralCollectionName);
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<    _finalColourNeutralCollectionName << " collection not available" << std::endl;
         fcncol = NULL;
@@ -491,7 +491,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       icncol = evt->getCollection( _initialColourNeutralCollectionName);
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<    _initialColourNeutralCollectionName << " collection not available" << std::endl;
         icncol = NULL;
@@ -504,7 +504,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       fcnlcol  = evt->getCollection(  _finalColourNeutralLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _finalColourNeutralLink   << " collection not available" << std::endl;
         fcnlcol  = NULL;
@@ -516,7 +516,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       icnlcol  = evt->getCollection(  _initialColourNeutralLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _initialColourNeutralLink  << " collection not available" << std::endl;
         fcnlcol  = NULL;
@@ -528,7 +528,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       fplcol  = evt->getCollection(  _finalElementonLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _finalElementonLink   << " collection not available" << std::endl;
         fcnlcol  = NULL;
@@ -540,7 +540,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       iplcol  = evt->getCollection(  _initialElementonLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _initialElementonLink   << " collection not available" << std::endl;
         fcnlcol  = NULL;
@@ -552,7 +552,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       tjrecolcol  = evt->getCollection(  _trueJetPFOLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _trueJetPFOLink   << " collection not available" << std::endl;
         fcnlcol  = NULL;
@@ -565,7 +565,7 @@ void TrueJet_Parser::getall( LCEvent * event ) {
     try{
       tjmcplcol  = evt->getCollection(  _trueJetMCParticleLink );
     }
-    catch( lcio::DataNotAvailableException e )
+    catch( const lcio::DataNotAvailableException& e )
     {
         streamlog_out(WARNING) <<  _trueJetMCParticleLink   << " collection not available" << std::endl;
         fcnlcol  = NULL;
diff --git a/Analysis/TruthVertexFinder/src/MCOperator.cc b/Analysis/TruthVertexFinder/src/MCOperator.cc
index 8fa869b..bef6c99 100644
--- a/Analysis/TruthVertexFinder/src/MCOperator.cc
+++ b/Analysis/TruthVertexFinder/src/MCOperator.cc
@@ -545,7 +545,6 @@ namespace TTbarAnalysis
 			streamlog_out(MESSAGE)<<"WARNING: Long-lived noninteracting particle " << parent->getPDG() <<"!\n";
 			return result;
 		}
-		bool finished = false;
 		for (unsigned int i = 0; i < daughters.size(); i++) 
 		{
 			MCParticle * daughter = daughters[i];
@@ -556,7 +555,6 @@ namespace TTbarAnalysis
 				{
 					//streamlog_out(MESSAGE)<<"CAUTION: Low momentum particle of " << MathOperator::getModule(daughter->getMomentum()) << " GeV!\n";
 				}
-				finished = true;
 				if (selectReco && IsReconstructed(daughter)) 
 				{
 					result.push_back(daughter);
diff --git a/Analysis/TruthVertexFinder/src/MathOperator.cc b/Analysis/TruthVertexFinder/src/MathOperator.cc
index f295ce0..810cb80 100644
--- a/Analysis/TruthVertexFinder/src/MathOperator.cc
+++ b/Analysis/TruthVertexFinder/src/MathOperator.cc
@@ -215,6 +215,7 @@ namespace TTbarAnalysis
 	}
 
 
+#if 0
 	double * MathOperator::castIntToDouble(int * array)
 	{
 		int size = (sizeof(array)/sizeof(*array));
@@ -229,6 +230,7 @@ namespace TTbarAnalysis
 		}
 		return arrPoint1;
 	}
+#endif
 	vector< vector< int > * > * MathOperator::GetMagicNumbers()
 	{
 		vector< vector< int > * > * result = new vector< vector< int > * >();
diff --git a/Analysis/TruthVertexFinder/src/TruthVertexFinder.cc b/Analysis/TruthVertexFinder/src/TruthVertexFinder.cc
index d042dbe..8ec72a6 100644
--- a/Analysis/TruthVertexFinder/src/TruthVertexFinder.cc
+++ b/Analysis/TruthVertexFinder/src/TruthVertexFinder.cc
@@ -237,7 +237,7 @@ namespace TTbarAnalysis
 		streamlog_out(MESSAGE) <<"|"<<particle->getPDG() <<"\t\t|"<<particle->getMass()<<"\t\t|"<<particle->getCharge()  <<"\t\t|"<<particle->getEnergy()<<"\t\t|"<<particle->getVertex()[0]<<"\t\t|"<<particle->getVertex()[1]<<"\t\t|"<<particle->getVertex()[2] <<"\t\t|\n";
 	
 	}
-	void TruthVertexFinder::Write(vector< Vertex * > * vertices, int & number)
+        void TruthVertexFinder::Write(vector< Vertex * > * vertices, int & /*number*/)
 	{
 		if (!vertices || vertices->size() < _pdgs.size()-1) 
 		{
@@ -498,10 +498,10 @@ namespace TTbarAnalysis
 			_bdistance = MathOperator::getDistance(verticies->at(1)->getPosition(), verticies->at(0)->getPosition());
 			_btotalnumber = _cnumber + _bnumber;
 			streamlog_out(MESSAGE) <<"Checking b-quark meson...\n";
-			bool compatible = opera.CheckCompatibility(daughters, chain->Get(0), chain->Get(1)->getCharge());
+			/*bool compatible =*/ opera.CheckCompatibility(daughters, chain->Get(0), chain->Get(1)->getCharge());
 				
 			streamlog_out(MESSAGE) <<"Checking c-quark meson...\n";
-			compatible = opera.CheckCompatibility(cdaughters, chain->Get(1));
+			/*compatible =*/ opera.CheckCompatibility(cdaughters, chain->Get(1));
 			_bptmiss = getMissingPt(daughters, cdaughters, verticies->at(0));
 			streamlog_out(MESSAGE) <<"Missing pt for b-quark hadron: " << _bptmiss << "\n";	
 			_ccharge = (int)chain->Get(1)->getCharge();
diff --git a/Analysis/VertexChargeRecovery/include/MathOperator.hh b/Analysis/VertexChargeRecovery/include/MathOperator.hh
index f19368b..f7be5d5 100644
--- a/Analysis/VertexChargeRecovery/include/MathOperator.hh
+++ b/Analysis/VertexChargeRecovery/include/MathOperator.hh
@@ -59,7 +59,7 @@ namespace TTbarAnalysis
 		//
 		//	Private methods
 		//
-			static double * castIntToDouble(int * array);
+          //static double * castIntToDouble(int * array);
 	};
 }
 #endif
diff --git a/Analysis/ZFinder/src/ZFinder.cc b/Analysis/ZFinder/src/ZFinder.cc
index 0ec8574..800a28d 100644
--- a/Analysis/ZFinder/src/ZFinder.cc
+++ b/Analysis/ZFinder/src/ZFinder.cc
@@ -240,15 +240,12 @@ void ZFinder::FindZmumu(LCCollectionVec * recparcol) {
   ReconstructedParticle* pMplus  = NULL;
   ReconstructedParticle* pMminus = NULL;
   float bestdmz = 999.;
-  unsigned int   besti=0;
-  unsigned int   bestj=0;
   for(unsigned int i=0;i<pmuplus.size();i++){  
     for(unsigned int j=0;j<pmuminus.size();j++){  
       LorentzVector pmumu = pmuplus[i]+pmuminus[j];
       float massmumu = pmumu.m();
       if( fabs(massmumu-91.2) < bestdmz){
 	bestdmz = fabs(massmumu-91.2);
-	besti=i; bestj=j;
 	pMplus  = pMplusPfoVec[i];
 	pMminus = pMminusPfoVec[j];
       }
@@ -365,7 +362,6 @@ void ZFinder::FindZee(LCCollectionVec * recparcol) {
   ReconstructedParticle* pEplus  = NULL;
   ReconstructedParticle* pEminus = NULL;
   float bestdmz = 999.;
-  unsigned int   besti = 999;
   unsigned int   bestj = 999;
   for(unsigned int i=0;i<peplus.size();i++){  
     for(unsigned int j=0;j<peminus.size();j++){  
@@ -373,7 +369,7 @@ void ZFinder::FindZee(LCCollectionVec * recparcol) {
       float massee = pee.m();
       if( fabs(massee-91.2) < bestdmz){
 	bestdmz = fabs(massee-91.2);
-	besti=i; bestj=j;
+	bestj=j;
 	pEplus = pEplusPfoVec[i];
 	pEminus = pEminusPfoVec[j];
       }
diff --git a/Calibration/AbsCalibration/src/AbsCalibr.cc b/Calibration/AbsCalibration/src/AbsCalibr.cc
index c4f57b9..e2033d1 100644
--- a/Calibration/AbsCalibration/src/AbsCalibr.cc
+++ b/Calibration/AbsCalibration/src/AbsCalibr.cc
@@ -295,7 +295,6 @@ double Balance(LCEvent * evt){
   int idpdg;
   const double* mom;
   float enr;
-  double mass;
   LCCollection* mcpCol = evt->getCollection("MCParticle" ) ;  
 //-----------------------------------------------------------------------
 // Calculate balance at IP taking into account everything
@@ -361,7 +360,6 @@ double Balance(LCEvent * evt){
     idpdg = imc-> getPDG (); 
     mom = imc-> getMomentum (); 
     enr = imc-> getEnergy (); 
-    mass = imc-> getMass (); 
     if( imc-> getGeneratorStatus() == 1) { // stable particles only   
       px = mom[0]; 
       py = mom[1]; 
diff --git a/CaloDigi/LDCCaloDigi/src/G2CD.cc b/CaloDigi/LDCCaloDigi/src/G2CD.cc
index 52ae21c..c78fd12 100644
--- a/CaloDigi/LDCCaloDigi/src/G2CD.cc
+++ b/CaloDigi/LDCCaloDigi/src/G2CD.cc
@@ -427,7 +427,7 @@ void G2CD::processEvent( LCEvent * evtP )
 
 					evtP->addCollection(ecalcol,_outputEcalCollections[k0].c_str());
 
-				}catch(lcio::DataNotAvailableException zero) { }
+				}catch(const lcio::DataNotAvailableException& zero) { }
 			}
 
 
@@ -618,12 +618,12 @@ void G2CD::processEvent( LCEvent * evtP )
 					evtP->addCollection(hcalcol,_outputHcalCollections[i].c_str());
 					IDtoDigiHit.clear();
 				}
-				catch (lcio::DataNotAvailableException zero) { }
+				catch (const lcio::DataNotAvailableException* zero) { }
 			}
 
 			evtP->addCollection(relcol, "CaloToSimuCaloLink");
 		}
-		catch (lcio::DataNotAvailableException zero) { }
+		catch (const lcio::DataNotAvailableException& zero) { }
 	}
 }
 
diff --git a/CaloDigi/LDCCaloDigi/src/ILDCaloDigi.cc b/CaloDigi/LDCCaloDigi/src/ILDCaloDigi.cc
index 73df039..201c334 100644
--- a/CaloDigi/LDCCaloDigi/src/ILDCaloDigi.cc
+++ b/CaloDigi/LDCCaloDigi/src/ILDCaloDigi.cc
@@ -640,7 +640,7 @@ void ILDCaloDigi::init() {
         }
 
         streamlog_out (MESSAGE) << "taking number of virtual cells from Mokka section of gear file: " << nVirtualMokkaS << " " << _strip_virt_cells << endl;
-      } catch(gear::UnknownParameterException &e) {                  // if still not found, use default from processor parameter
+      } catch(gear::UnknownParameterException &) {                  // if still not found, use default from processor parameter
         _strip_virt_cells = _ecalStrip_default_nVirt;
         streamlog_out (WARNING) << "taking number of virtual cells from steering file (not found in gear file): " << _strip_virt_cells << endl;
       }
@@ -654,13 +654,13 @@ void ILDCaloDigi::init() {
       try {
         _ecalLayout = pMokka.getStringVal("Ecal_Sc_Si_mix");
         streamlog_out (MESSAGE) << "taking layer layout from mokka section of gear file: " << _ecalLayout << endl;
-      } catch(gear::UnknownParameterException &e) {
+      } catch(gear::UnknownParameterException &) {
         _ecalLayout = _ecal_deafult_layer_config;
         streamlog_out (WARNING) << "taking layer layout from steering file (not found in gear file): " << _ecalLayout << endl;
       }
     }
 
-  } catch(gear::UnknownParameterException &e) {
+  } catch(gear::UnknownParameterException &) {
     streamlog_out (WARNING) << "WARNING, could not get ECAL gear parameters!" << endl;
   }
 
@@ -869,9 +869,9 @@ void ILDCaloDigi::processEvent( LCEvent * evt ) {
             float eCellInTime = 0.;
             float eCellOutput = 0.;
 
-            for(unsigned int i =0; i<n;i++){
-              float timei   = hit->getTimeCont(i);
-              float energyi = hit->getEnergyCont(i);
+            for(unsigned int ii =0; ii<n;ii++){
+              float timei   = hit->getTimeCont(ii);
+              float energyi = hit->getEnergyCont(ii);
       	      float energySum = 0;
 
               float deltat = 0;
@@ -881,27 +881,27 @@ void ILDCaloDigi::processEvent( LCEvent * evt ) {
                 eCellInTime+=ecor;
               }
 
-              if(!used[i]){
+              if(!used[ii]){
                 // merge with other hits?
-                used[i] = true;
-                for(unsigned int j =i+1; j<n;j++){
-                  if(!used[j]){
-                    float timej   = hit->getTimeCont(j);
-                    float energyj = hit->getEnergyCont(j);
-                    float deltat = fabs(timei-timej);
+                used[ii] = true;
+                for(unsigned int jj =ii+1; jj<n;jj++){
+                  if(!used[jj]){
+                    float timej   = hit->getTimeCont(jj);
+                    float energyj = hit->getEnergyCont(jj);
+                    float deltat_ = fabs(timei-timej);
 		    if (_ecalSimpleTimingCut){
-			    float deltat = _ecalCorrectTimesForPropagation?dt:0;
-			    if (timej-deltat>_ecalTimeWindowMin && timej-deltat<ecalTimeWindowMax){
+			    float deltat2 = _ecalCorrectTimesForPropagation?dt:0;
+			    if (timej-deltat2>_ecalTimeWindowMin && timej-deltat2<ecalTimeWindowMax){
 				    energySum += energyj;
 				    if (timej < timei){
 					    timei = timej;
 				    }
 			    }
 		    } else {
-			if(deltat<_ecalDeltaTimeHitResolution){
+			if(deltat_<_ecalDeltaTimeHitResolution){
 			if(energyj>energyi)timei=timej;
 			energyi+=energyj;
-			used[j] = true;
+			used[jj] = true;
 			}
 		    }
                   }
@@ -1103,13 +1103,11 @@ void ILDCaloDigi::processEvent( LCEvent * evt ) {
 
             int count = 0;
          
-            for(unsigned int i =0; i<n;i++){ // loop over all subhits
-              float timei   = hit->getTimeCont(i); //absolute hit timing of current subhit
-              float energyi = hit->getEnergyCont(i); //energy of current subhit
+            for(unsigned int ii =0; ii<n;ii++){ // loop over all subhits
+              float timei   = hit->getTimeCont(ii); //absolute hit timing of current subhit
+              float energyi = hit->getEnergyCont(ii); //energy of current subhit
 	      float energySum = 0;
-              float deltat = 0;
-              if(_hcalCorrectTimesForPropagation)deltat=dt;  //deltat now carries hit timing correction.
-	      //std::cout <<"outer:" << i << " " << n << std::endl;
+	      //std::cout <<"outer:" << ii << " " << n << std::endl;
 
               //idea of the following section: 
               //if simpletimingcut == false
@@ -1121,31 +1119,31 @@ void ILDCaloDigi::processEvent( LCEvent * evt ) {
               //sum up hit energies within timeWindowMin and timeWindowMax, use earliest subhit in this window as hit time for resulting calohit.
               //only one calorimeterhit will be generated from this.
               
-              if(!used[i]){ //if current subhit has not been merged with previous hits already, take current hit as starting point to merge hits
+              if(!used[ii]){ //if current subhit has not been merged with previous hits already, take current hit as starting point to merge hits
                 // merge with other hits?
-                used[i] = true;
-                for(unsigned int j =i; j<n;j++){//loop through all hits after current hit
-		  //std::cout << "inner:" << i << " " << j << " " << n << std::endl;
-                  if(!used[j]){
-                    float timej   = hit->getTimeCont(j);
-                    float energyj = hit->getEnergyCont(j);
-                    float deltat = fabs(timei-timej);
-                    //              std::cout << " HCAL  deltat : " << deltat << std::endl;
+                used[ii] = true;
+                for(unsigned int jj =ii; jj<n;jj++){//loop through all hits after current hit
+		  //std::cout << "inner:" << ii << " " << jj << " " << n << std::endl;
+                  if(!used[jj]){
+                    float timej   = hit->getTimeCont(jj);
+                    float energyj = hit->getEnergyCont(jj);
+                    float deltat_ = fabs(timei-timej);
+                    //              std::cout << " HCAL  deltat : " << deltat_ << std::endl;
 		    if (_hcalSimpleTimingCut){
-			    float deltat = _hcalCorrectTimesForPropagation?dt:0;
-			    if (timej-deltat>_hcalTimeWindowMin && timej-deltat<hcalTimeWindowMax){
+			    float deltat2 = _hcalCorrectTimesForPropagation?dt:0;
+			    if (timej-deltat2>_hcalTimeWindowMin && timej-deltat2<hcalTimeWindowMax){
 				    energySum += energyj;
 				    if (timej<timei){
 					    timei = timej; //use earliest hit time for simpletimingcut
 				    }
 			    }
 		    } else {
-			if(deltat<_hcalDeltaTimeHitResolution){ //if this subhit is close to current subhit, add this hit's energy to timecluster
+			if(deltat_<_hcalDeltaTimeHitResolution){ //if this subhit is close to current subhit, add this hit's energy to timecluster
 			if(energyj>energyi)timei=timej; //this is probably not what was intended. i guess this should find the largest hit of one timecluster and use its hittime for the cluster, but instead it compares the current hit energy to the sum of already found hit energies
 			//std::cout << timei << " - " << timej << std::endl;
 			//std::cout << energyi << " - " << energyj << std::endl;
 			energyi+=energyj;
-			used[j] = true;
+			used[jj] = true;
 			//std::cout << timei << " " << energyi << std::endl;
 			}
 		    }
diff --git a/CaloDigi/LDCCaloDigi/src/MokkaCaloDigi.cc b/CaloDigi/LDCCaloDigi/src/MokkaCaloDigi.cc
index d1e7ae4..de4b3d4 100644
--- a/CaloDigi/LDCCaloDigi/src/MokkaCaloDigi.cc
+++ b/CaloDigi/LDCCaloDigi/src/MokkaCaloDigi.cc
@@ -221,14 +221,14 @@ void MokkaCaloDigi::init() {
     }
 
     if (z >= y_dim1_for_z && z < (y_dim1_for_z+y_dim2_for_z)) {
-      float z = 
+      float z_ = 
 	_regularBarrelModuleLength-2*_lateralPlateThickness+(id*_hcalAbsorberThickness+(id-1)*_hcalSensitiveThickness-y_dim1_for_z)*(top_end_dim_z-_regularBarrelModuleLength)/y_dim2_for_z;
-      z_width = int(z/_virtualCellSizeZ)*_virtualCellSizeZ;
+      z_width = int(z_/_virtualCellSizeZ)*_virtualCellSizeZ;
     }
 
     if (z >= (y_dim1_for_z+y_dim2_for_z) ) {
-      float z = top_end_dim_z - 2*_lateralPlateThickness;
-      z_width = int(z/_virtualCellSizeZ)*_virtualCellSizeZ;
+      float z_ = top_end_dim_z - 2*_lateralPlateThickness;
+      z_width = int(z_/_virtualCellSizeZ)*_virtualCellSizeZ;
     }
 
 
@@ -464,8 +464,6 @@ MyHit * MokkaCaloDigi::ProcessHitInBarrel( SimCalorimeterHit * hit ) {
   int I=(cellid & MASK_I) >> SHIFT_I; // I
 
   float zBegin = 0.;
-  float chamberLength = 0.;
-  float offsetMaxZ;
 
   // calculation of the lower z coordinate of the sensitive part of barrel module
   if (Module == 1) {
@@ -484,12 +482,8 @@ MyHit * MokkaCaloDigi::ProcessHitInBarrel( SimCalorimeterHit * hit ) {
     zBegin = 1.5*_regularBarrelModuleLength + 2*_modulesGap + _lateralPlateThickness;
   }
   if (Module == 1 || Module == 5) {
-    chamberLength = _endBarrelChamberLength[Layer];
-    offsetMaxZ = _endBarrelOffsetMaxZ[Layer];
   }
   else {
-    chamberLength = _regularBarrelChamberLength;
-    offsetMaxZ = _regularBarrelOffsetMaxZ;
   }
 
 
diff --git a/CaloDigi/LDCCaloDigi/src/SimpleFCalDigi.cc b/CaloDigi/LDCCaloDigi/src/SimpleFCalDigi.cc
index eecf04c..aa4b2c1 100644
--- a/CaloDigi/LDCCaloDigi/src/SimpleFCalDigi.cc
+++ b/CaloDigi/LDCCaloDigi/src/SimpleFCalDigi.cc
@@ -171,15 +171,15 @@ void SimpleFCalDigi::processEvent( LCEvent * evt ) {
                  _fixLCalHits          ) {  
             // fix for wrong cellID to xyz coding in LCal Mokka
 
-            int i = idDecoder(hit)[ "I" ] ;
-            int j = idDecoder(hit)[ "J" ] ;
+            int i_ = idDecoder(hit)[ "I" ] ;
+            int j_ = idDecoder(hit)[ "J" ] ;
             int k = idDecoder(hit)[ "K" ] ;
             int s = idDecoder(hit)[ "S-1" ] ;
 
 	    float z_from_cell = ( zMin + (k-1) * dZ + (dZ- WThickness)/2.0 ) - 0.11 ; // 0.11 is a guess on the sensorthikness
-            float r_from_cell =  i*cellDimR + cellDimR/2.0 + rMin; 
+            float r_from_cell =  i_*cellDimR + cellDimR/2.0 + rMin; 
             int   oddeven = ((k+1)%2) ;
-            float phi_from_cell = j*cellDimPhi + cellDimPhi/2.0 - oddeven*cellDimPhi/2.0;
+            float phi_from_cell = j_*cellDimPhi + cellDimPhi/2.0 - oddeven*cellDimPhi/2.0;
 
             float angle= -(xing_angle*1.0e-3 / 2.0)* (2 * ( s - 0.5 ) ) - ( s - 1 )*3.14159  ; 
             float rotated_z_from_cell=    z_from_cell*cos( angle) + r_from_cell*cos(phi_from_cell)*sin( angle);
@@ -189,7 +189,7 @@ void SimpleFCalDigi::processEvent( LCEvent * evt ) {
             pos[1] =  r_from_cell*sin(phi_from_cell) ; 
             pos[2]=rotated_z_from_cell;
 
-	    streamlog_out( DEBUG3 ) << "i,j,k,s : " << i << " " << j << " " << k << " " << s << " " << oddeven << std::endl;
+	    streamlog_out( DEBUG3 ) << "i,j,k,s : " << i_ << " " << j_ << " " << k << " " << s << " " << oddeven << std::endl;
             streamlog_out( DEBUG3 ) << "xyzr  input                         : " << hit->getPosition()[0] << " " << hit->getPosition()[1]  << " " << hit->getPosition()[2] << " " << 
 	      sqrt(hit->getPosition()[0]*hit->getPosition()[0]+hit->getPosition()[1]*hit->getPosition()[1]) << std::endl;
 	    streamlog_out( DEBUG3 ) << "xyzr with r and z fr cellID rotated : " << pos[0] << " " << pos[1] << " " << pos[2] << " " << 
diff --git a/CaloDigi/Realistic/src/RealisticCaloDigiScinPpd.cc b/CaloDigi/Realistic/src/RealisticCaloDigiScinPpd.cc
index c92a682..cbd233c 100644
--- a/CaloDigi/Realistic/src/RealisticCaloDigiScinPpd.cc
+++ b/CaloDigi/Realistic/src/RealisticCaloDigiScinPpd.cc
@@ -52,7 +52,7 @@ float RealisticCaloDigiScinPpd::convertEnergy( float energy, int inUnit ) { // c
   else if ( inUnit==MIP ) return _PPD_pe_per_mip*energy;
   else if ( inUnit==GEVDEP ) return _PPD_pe_per_mip*energy/_calib_mip;
   else streamlog_out (ERROR) << "unknown unit " << inUnit << std::endl;
-  assert (0);
+  std::abort();
 }
 
 float RealisticCaloDigiScinPpd::digitiseDetectorEnergy(float energy) {
diff --git a/CaloDigi/Realistic/src/RealisticCaloDigiSilicon.cc b/CaloDigi/Realistic/src/RealisticCaloDigiSilicon.cc
index 4ee70e8..28602b4 100644
--- a/CaloDigi/Realistic/src/RealisticCaloDigiSilicon.cc
+++ b/CaloDigi/Realistic/src/RealisticCaloDigiSilicon.cc
@@ -31,7 +31,7 @@ float RealisticCaloDigiSilicon::convertEnergy( float energy, int inUnit ) { // c
   if      ( inUnit==MIP ) return energy;
   else if ( inUnit==GEVDEP ) return energy/_calib_mip;
   else streamlog_out (ERROR) << "RealisticCaloDigiSilicon::convertEnergy - unknown unit " << inUnit << std::endl;
-  assert (0);
+  std::abort();
 }
 
 
diff --git a/Clustering/PhotonFinderKit/src/KITutil.cc b/Clustering/PhotonFinderKit/src/KITutil.cc
index 5c47d6a..ac32178 100644
--- a/Clustering/PhotonFinderKit/src/KITutil.cc
+++ b/Clustering/PhotonFinderKit/src/KITutil.cc
@@ -141,12 +141,10 @@ void Precalc2(vector< Superhit2* >& shvec,double r, double z, double cell, doubl
 
            unsigned int nPts=shvec.size();
            ANNpointArray dataPts;
-           ANNpoint queryPt;
            ANNidxArray nnIdx;
            ANNdistArray dists;
            ANNkd_tree* kdTree;
 
-	   queryPt=annAllocPt(3); // 3d point 
 	   dataPts=annAllocPts(nPts,3);
            nnIdx=new ANNidx[36];
 	   dists=new ANNdist[36];
@@ -287,7 +285,6 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 		unsigned int N, vector<float> miipstep, CoreCut2 Ccut)
 {       
           typedef pair<int,int>   test;
-	  int psl_plun_global=0;
 	  
 	  double Diagby2=PGDB[PGdb::ECAL1_BAR].cell_size*sqrt(2.0)/2.0;
 	  double d=PGDB[PGdb::ECAL1_BAR].r_inner;
@@ -341,7 +338,6 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 		}
 	      poslednjipun=im;
 	    }
-	  psl_plun_global=poslednjipun;
 	 
 	  vector < PROTSEED2 > prs;
 
@@ -460,11 +456,11 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 			      a.X[2]=Xatf[2];
 			      a.active=true;
 			      bool stavi=true;
-			      for( unsigned int im=0;im<prs2->size();im++)
+			      for( unsigned int iim=0;iim<prs2->size();iim++)
 				{
-				  if((*prs2)[im].active)
+				  if((*prs2)[iim].active)
 				    {
-				      if( (*prs2)[im].cl==a.cl)
+				      if( (*prs2)[iim].cl==a.cl)
 					stavi=false;
 				    }
 				}
@@ -494,11 +490,11 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 			  a.active=true;
 		
 			  bool stavi=true;
-			  for( unsigned int im=0;im<prs2->size();im++)
+			  for( unsigned int iim=0;iim<prs2->size();iim++)
 			    {
-			      if((*prs2)[im].active)
+			      if((*prs2)[iim].active)
 				{
-				  if( (*prs2)[im].cl==a.cl)
+				  if( (*prs2)[iim].cl==a.cl)
 				    stavi=false;
 				}
 			    }
@@ -562,8 +558,8 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 
 	  if(kojsv.size()!=0)
 	    {
-           
-	      int iskoristio[kojsv.size()];
+
+              std::vector<int> iskoristio(kojsv.size());
 	      for(unsigned int i=0;i<kojsv.size();i++)
 		{
 		  iskoristio[i]=0;
@@ -687,7 +683,7 @@ void FindCores2(Shitvec2* secal1, vector<Tmpclvec2>& bbb , vector <PROTSEED2> *
 		       }else{
                           
 		       vector <int> izabrani;
-		       int isko[trojka.size()];
+                       std::vector<int> isko (trojka.size());
 		       for(unsigned int jj=0;jj<trojka.size();jj++)
 			     {
 			       isko[jj]=0;
@@ -1158,22 +1154,22 @@ void LineCaloIntersect2(double* X1, double* X2,double&d,double&zmax,  double*X)
       }
    
     }else { // endcap 
-                double n[8][3];
+                double n_[8][3];
                 if(X2[2]>0.0)
                  {
-		   n[0][0]=0.0; 
-		   n[0][1]=0.0;
-		   n[0][2]=1.0;
+		   n_[0][0]=0.0; 
+		   n_[0][1]=0.0;
+		   n_[0][2]=1.0;
 		 }else{
-		  n[0][0]=0.0; 
-		  n[0][1]=0.0;
-		  n[0][2]=-1.0;
+		  n_[0][0]=0.0; 
+		  n_[0][1]=0.0;
+		  n_[0][2]=-1.0;
 		}
 
 
-		double tmp=-(n[0][0]*n[0][0]+n[0][1]*n[0][1]+n[0][2]*n[0][2])*zmax
-		            +n[0][0]*X1[0]+n[0][1]*X1[1]+n[0][2]*X1[2];
-		double tmp2=n[0][0]*(X1[0]-X2[0])+n[0][1]*(X1[1]-X2[1])+n[0][2]*(X1[2]-X2[2]);
+		double tmp=-(n_[0][0]*n_[0][0]+n_[0][1]*n_[0][1]+n_[0][2]*n_[0][2])*zmax
+		            +n_[0][0]*X1[0]+n_[0][1]*X1[1]+n_[0][2]*X1[2];
+		double tmp2=n_[0][0]*(X1[0]-X2[0])+n_[0][1]*(X1[1]-X2[1])+n_[0][2]*(X1[2]-X2[2]);
 		double t=0.0;
      
 		if(tmp2!=0.0)
diff --git a/Clustering/hybridEcalSplitter/src/hybridRecoProcessor.cc b/Clustering/hybridEcalSplitter/src/hybridRecoProcessor.cc
index 881c3f2..bb2cf0d 100644
--- a/Clustering/hybridEcalSplitter/src/hybridRecoProcessor.cc
+++ b/Clustering/hybridEcalSplitter/src/hybridRecoProcessor.cc
@@ -175,7 +175,7 @@ void hybridRecoProcessor::setupGeometry() {
 	assert(0);
       }
       streamlog_out (MESSAGE) << "taking number of Mokka virtual cells from Mokka section of gear file: " << nVirtualMokkaS << " " << nMokkaVirtualCells << endl;
-    } catch(gear::UnknownParameterException &e) {
+    } catch(const gear::UnknownParameterException &) {
       // if still not found, use default from processor parameter
       nMokkaVirtualCells = _ecalStrip_default_nVirt;
       streamlog_out (WARNING) << "taking number of Mokka virtual cells from steering file (not found in gear file): " << nMokkaVirtualCells << endl;
@@ -226,16 +226,12 @@ void hybridRecoProcessor::processEvent( LCEvent * evt ) {
 
   if (_makePlots) {
     // first fill some simple MC histos
-    float phi=-999;
-    float theta=-999;
     try {
       LCCollection * col = evt->getCollection("MCParticle");
       if (col->getNumberOfElements()>0) {
 	MCParticle * mcp = dynamic_cast<MCParticle*>(col->getElementAt(0) );
 	TVector3 mom(mcp->getMomentum()[0], mcp->getMomentum()[1], mcp->getMomentum()[2]);
 	h_phiThetaMC->Fill(mom.Phi(), mom.Theta());
-	phi = mom.Phi();
-	theta = mom.Theta();
       }
     }
     catch(DataNotAvailableException &e) {};
@@ -249,7 +245,6 @@ void hybridRecoProcessor::processEvent( LCEvent * evt ) {
 
   std::pair < TVector3, TVector3 > stripEnds;
   std::vector <std::string> * toSplit;
-  std::vector <std::string> * stripSplitter;
   int orientation;
 
   std::map < IMPL::LCCollectionVec*, std::string > outputcolls;
@@ -270,12 +265,10 @@ void hybridRecoProcessor::processEvent( LCEvent * evt ) {
     case 0:
       orientation = TRANSVERSE;
       toSplit = &_ecalCollectionsTranStrips;
-      stripSplitter = &_ecalCollectionsLongStrips;
       break;
     case 1:
       orientation = LONGITUDINAL;
       toSplit = &_ecalCollectionsLongStrips;
-      stripSplitter = &_ecalCollectionsTranStrips;
       break;
     default:
       streamlog_out ( ERROR ) << "ERROR crazy stuff!!! abandoning event..." << endl;
@@ -398,22 +391,22 @@ std::vector <CalorimeterHit*> hybridRecoProcessor::getVirtualHits(LCEvent* evt,
   if (_saveIntersections) { 
     // make new collection with a hit at each end of a strip
     //   for debugging purposes
-    float pp[3];
-    pp[0] = stripEnds.first.X();
-    pp[1] = stripEnds.first.Y();
-    pp[2] = stripEnds.first.Z();
+    float pp_[3];
+    pp_[0] = stripEnds.first.X();
+    pp_[1] = stripEnds.first.Y();
+    pp_[2] = stripEnds.first.Z();
     CalorimeterHitImpl* interhit = new CalorimeterHitImpl();
-    interhit->setPosition( pp );
+    interhit->setPosition( pp_ );
     interhit->setEnergy(0.03);
 
     if (orientation==TRANSVERSE) stripEndsTransCol->addElement(interhit);
     else if (orientation==LONGITUDINAL) stripEndsLongCol->addElement(interhit);
 
-    pp[0] = stripEnds.second.X();
-    pp[1] = stripEnds.second.Y();
-    pp[2] = stripEnds.second.Z();
+    pp_[0] = stripEnds.second.X();
+    pp_[1] = stripEnds.second.Y();
+    pp_[2] = stripEnds.second.Z();
     interhit = new CalorimeterHitImpl();
-    interhit->setPosition( pp );
+    interhit->setPosition( pp_ );
     interhit->setEnergy(0.03);
 
     if (orientation==TRANSVERSE) stripEndsTransCol->addElement(interhit);
@@ -507,10 +500,10 @@ std::vector <CalorimeterHit*> hybridRecoProcessor::getVirtualHits(LCEvent* evt,
 	  if (intercept.Mag()>0) { // intercept found, calculate in which virtual cell
 	    nSplitters++;
 	    float frac(-1);
-	    for (int i=0; i<3; i++) {
-	      float dx = stripEnds.second[i] - stripEnds.first[i];
+	    for (int ii=0; ii<3; ii++) {
+	      float dx = stripEnds.second[ii] - stripEnds.first[ii];
 	      if (fabs(dx)>0.1) {
-		frac = (intercept[i]-stripEnds.first[i])/dx;
+		frac = (intercept[ii]-stripEnds.first[ii])/dx;
 		break;
 	      }
 	    }
diff --git a/PFOID/src/CreatePDFs.cc b/PFOID/src/CreatePDFs.cc
index 96fe3f7..8f8c032 100644
--- a/PFOID/src/CreatePDFs.cc
+++ b/PFOID/src/CreatePDFs.cc
@@ -487,10 +487,10 @@ void CreatePDFs::processEvent( LCEvent * evt ) {
           Track *track=NULL;
           FloatVec weight = TrackToMCPNav.getRelatedFromWeights(mcp);
           float weightmax=-1.0;
-          for(unsigned int i=0; i<ovt.size(); i++){
-            if(weight[i]>weightmax){
-              weightmax=weight[i];
-              track = dynamic_cast<Track*>(ovt[i]);
+          for(unsigned int ii=0; ii<ovt.size(); ii++){
+            if(weight[ii]>weightmax){
+              weightmax=weight[ii];
+              track = dynamic_cast<Track*>(ovt[ii]);
             }// if ...
           }// for( int i=0 ...
           if(track!=NULL){
diff --git a/TimeOfFlight/src/TOFEstimators.cc b/TimeOfFlight/src/TOFEstimators.cc
index aa35a45..f373212 100644
--- a/TimeOfFlight/src/TOFEstimators.cc
+++ b/TimeOfFlight/src/TOFEstimators.cc
@@ -122,7 +122,7 @@ void TOFEstimators::processEvent( LCEvent * evt ) {
   try{
     colPFO = evt->getCollection( _colNamePFO ) ;
   }
-  catch(lcio::Exception){
+  catch(const lcio::Exception&){
     streamlog_out( DEBUG6 ) << " collection " << _colNamePFO
 			    << " not found in event - nothing to do ... " << std::endl ;
   }
@@ -403,7 +403,7 @@ void TOFEstimators::check( LCEvent *evt) {
 
   // get the PFO collection from the event if it exists
   LCCollection* colPFO = nullptr ;
-  try{ colPFO = evt->getCollection( _colNamePFO ) ; } catch(lcio::Exception){}
+  try{ colPFO = evt->getCollection( _colNamePFO ) ; } catch(const lcio::Exception&){}
 
   if( colPFO != nullptr ){
   
diff --git a/TimeOfFlight/src/TOFPlots.cc b/TimeOfFlight/src/TOFPlots.cc
index 77924dc..c1cd6dd 100644
--- a/TimeOfFlight/src/TOFPlots.cc
+++ b/TimeOfFlight/src/TOFPlots.cc
@@ -289,8 +289,8 @@ void TOFPlots::processEvent( LCEvent * evt ) {
   LCCollection* colMCP=0 ;
   LCCollection* colPFO=0 ;
     
-  try{ colMCP = evt->getCollection( _colNameMCP ) ; } catch(lcio::Exception){}
-  try{ colPFO = evt->getCollection( _colNamePFO ) ; } catch(lcio::Exception){}
+  try{ colMCP = evt->getCollection( _colNameMCP ) ; } catch(const lcio::Exception&){}
+  try{ colPFO = evt->getCollection( _colNamePFO ) ; } catch(const lcio::Exception&){}
 
 
   if( colMCP != NULL ){
diff --git a/TrackDigi/FPCCDDigi/src/FPCCDClustering.cc b/TrackDigi/FPCCDDigi/src/FPCCDClustering.cc
index 4d00238..979290d 100644
--- a/TrackDigi/FPCCDDigi/src/FPCCDClustering.cc
+++ b/TrackDigi/FPCCDDigi/src/FPCCDClustering.cc
@@ -914,7 +914,7 @@ void FPCCDClustering::makeTrackerHitVec(FPCCDData* pHitData, LCCollection* STHco
 
 
 
-void FPCCDClustering::makeTrackerHit(LCCollection* STHcol, int layer, int ladder, FPCCDClusterVec_t &clusterVec, std::multimap< std::pair<int,int>, SimTrackerHit*> relMap, LCCollectionVec* relCol, LCCollectionVec* trkHitVec )
+void FPCCDClustering::makeTrackerHit(LCCollection* STHcol, int layer, int ladder, FPCCDClusterVec_t &clusterVec, std::multimap< std::pair<int,int>, SimTrackerHit*> /*relMap*/, LCCollectionVec* relCol, LCCollectionVec* trkHitVec )
 {
   //trkHitVec and relCol is yet void data. 
   //This Version is different from default version at the point of last area of this function scope.
@@ -968,7 +968,8 @@ void FPCCDClustering::makeTrackerHit(LCCollection* STHcol, int layer, int ladder
       FPCCDPixelHit::HitQuality_t addedQuality = aHit->getQuality();
       if( trackquality != FPCCDPixelHit::kBKGOverlap){
         if(trackquality == FPCCDPixelHit::kBKG){
-          addedQuality=FPCCDPixelHit::kBKG ? trackquality=FPCCDPixelHit::kBKG : trackquality=FPCCDPixelHit::kBKGOverlap;
+          bool flag = FPCCDPixelHit::kBKG != 0;
+          addedQuality=flag ? trackquality=FPCCDPixelHit::kBKG : trackquality=FPCCDPixelHit::kBKGOverlap;
         }
       }
       else if(addedQuality==FPCCDPixelHit::kSignalOverlap){trackquality=FPCCDPixelHit::kSignalOverlap;       }
diff --git a/TrackDigi/TPCDigi/src/TPCDigiProcessor.cc b/TrackDigi/TPCDigi/src/TPCDigiProcessor.cc
index 07fb439..3bc7c79 100644
--- a/TrackDigi/TPCDigi/src/TPCDigiProcessor.cc
+++ b/TrackDigi/TPCDigi/src/TPCDigiProcessor.cc
@@ -487,7 +487,7 @@ void TPCDigiProcessor::processEvent( LCEvent * evt )
       
       _SimTHit = dynamic_cast<SimTrackerHit*>( STHcol->getElementAt( i ) ) ;
       
-      float edep;
+      float edep_;
       double padPhi(0.0);
       double padTheta (0.0);
       
@@ -675,7 +675,7 @@ void TPCDigiProcessor::processEvent( LCEvent * evt )
         continue;
       }
       
-      edep = _SimTHit->getEDep();
+      edep_ = _SimTHit->getEDep();
       
       // Calculate Point Resolutions according to Ron's Formula 
       
@@ -746,10 +746,10 @@ void TPCDigiProcessor::processEvent( LCEvent * evt )
       }
       
       //get energy deposit of this row
-      edep=_SimTHit->getEDep();
+      edep_=_SimTHit->getEDep();
 
       // create a tpc voxel hit and store it for this row
-      Voxel_tpc * atpcVoxel = new Voxel_tpc(iRowHit,iPhiHit,iZHit, thisPoint, edep, tpcRPhiRes, tpcZRes);
+      Voxel_tpc * atpcVoxel = new Voxel_tpc(iRowHit,iPhiHit,iZHit, thisPoint, edep_, tpcRPhiRes, tpcZRes);
       
       _tpcRowHits.at(iRowHit).push_back(atpcVoxel);
       ++numberOfVoxelsCreated;
@@ -1091,8 +1091,6 @@ void TPCDigiProcessor::end()
 void TPCDigiProcessor::writeVoxelToHit( Voxel_tpc* aVoxel){
   
   const gear::TPCParameters& gearTPC = Global::GEAR->getTPCParameters() ;
-  const gear::PadRowLayout2D& padLayout = gearTPC.getPadLayout() ;
-  const gear::Vector2D padCoord = padLayout.getPadCenter(1) ;
   
   Voxel_tpc* seed_hit  = aVoxel;
   
@@ -1219,7 +1217,6 @@ void TPCDigiProcessor::writeMergedVoxelsToHit( vector <Voxel_tpc*>* hitsToMerge)
   
   const gear::TPCParameters& gearTPC = Global::GEAR->getTPCParameters() ;
   const gear::PadRowLayout2D& padLayout = gearTPC.getPadLayout() ;
-  const gear::Vector2D padCoord = padLayout.getPadCenter(1) ;
   
   TrackerHitImpl* trkHit = new TrackerHitImpl ;
   
diff --git a/TrackDigi/TPCDigi/src/voxel.cc b/TrackDigi/TPCDigi/src/voxel.cc
index bfa801a..700ff77 100644
--- a/TrackDigi/TPCDigi/src/voxel.cc
+++ b/TrackDigi/TPCDigi/src/voxel.cc
@@ -7,7 +7,7 @@ using namespace std;
 
 Voxel_tpc::Voxel_tpc(){
 }
-Voxel_tpc::Voxel_tpc(int row, int phi, int z, double pos[3], double posRPhi[2], double edep, double RPhiRes, double ZRes)
+Voxel_tpc::Voxel_tpc(int row, int phi, int z, double pos[3], double /*posRPhi*/[2], double edep, double RPhiRes, double ZRes)
 {
   _row_index = row;
   _phi_index = phi;
diff --git a/TrackDigi/VTXDigi/src/CCDDigitizer.cc b/TrackDigi/VTXDigi/src/CCDDigitizer.cc
index a94488b..b4d5427 100644
--- a/TrackDigi/VTXDigi/src/CCDDigitizer.cc
+++ b/TrackDigi/VTXDigi/src/CCDDigitizer.cc
@@ -509,8 +509,8 @@ void CCDDigitizer::processEvent( LCEvent * evt ) {
           RelCol->addElement(rel);
         }
 // Clean Up        
-        for (int i=0; i < int(simTrkHitVec.size()); ++i) {
-          SimTrackerHit * hit = simTrkHitVec[i];
+        for (int ii=0; ii < int(simTrkHitVec.size()); ++ii) {
+          SimTrackerHit * hit = simTrkHitVec[ii];
           delete hit;
         }     
       } 
@@ -669,14 +669,12 @@ void CCDDigitizer::FindLocalPosition(SimTrackerHit * hit,
   //cout<<"nLadders "<<nLadders<<" "<<dPhi<<" "<<Phi0<<" "<<endl;
   
 
-  int iLadder=0;
   for (int ic=0; ic<nLadders; ++ic) {
     PhiLadder = double(ic)*dPhi + Phi0;
     PhiInLocal = PhiInLab - PhiLadder;
     //cout<<"Phi "<<PhiLadder<<" "<<PhiInLocal<<" "<<PhiInLab<<" "<<_layerThickness[layer]<<" "<<Radius<<endl;
     if (RXY*cos(PhiInLocal)-Radius > -_layerThickness[layer] && 
         RXY*cos(PhiInLocal)-Radius < _layerThickness[layer]) {
-      iLadder = ic;
       break;
     }
     //cout<<"phi ladder "<<PhiLadder<<endl;
@@ -883,18 +881,18 @@ void CCDDigitizer::ProduceHits( SimTrackerHitImplVec & vectorOfHits) {
        diffusion(xdif, ydif,sigmadirect);
        //diffusiontable(xdif, ydif,sigmadirect);
       
-      for(int i=0;i<maxpixx;i++){
+      for(int ii=0;ii<maxpixx;ii++){
         for(int k=0;k<maxpixy;k++){
           
-          spxl[i][k]= (1-weight) * pxl[i][k];
+          spxl[ii][k]= (1-weight) * pxl[ii][k];
         }
       }
       
       diffusion(xdif, ydif,sigmareflect);
       //diffusiontable(xdif, ydif,sigmareflect);
-      for(int i=0;i<maxpixx;i++){
+      for(int ii=0;ii<maxpixx;ii++){
         for(int k=0;k<maxpixy;k++){
-          pxl[i][k]= spxl[i][k]+ weight * pxl[i][k]; 
+          pxl[ii][k]= spxl[ii][k]+ weight * pxl[ii][k]; 
         }
       }      
       //  delete spxl;
@@ -927,7 +925,7 @@ void CCDDigitizer::ProduceHits( SimTrackerHitImplVec & vectorOfHits) {
     double Numladderpixy=(int)(ladderlength/_pixelSizeY); 
      
 
-    for (int i = 0; i<maxpixx; i++) {
+    for (int ii = 0; ii<maxpixx; ii++) {
       int ix=i+xcell-midpixx;
       // if(_debug)cout<<ix<<","<<endl;
 
@@ -938,7 +936,7 @@ void CCDDigitizer::ProduceHits( SimTrackerHitImplVec & vectorOfHits) {
           if (iy >=0 && iy<=Numladderpixy) {
 
 
-            double charge=(1e+6*energy*_electronsPerKeV) *pxl[i][k]; 
+            double charge=(1e+6*energy*_electronsPerKeV) *pxl[ii][k]; 
             // if(_debug)cout<<"charge   " <<i<<" "<<k<<" "<<charge<<endl;
             int iexist = 0;
 
diff --git a/TrackDigi/VTXDigi/src/VTXBgClusters.cc b/TrackDigi/VTXDigi/src/VTXBgClusters.cc
index 5110706..69d2846 100644
--- a/TrackDigi/VTXDigi/src/VTXBgClusters.cc
+++ b/TrackDigi/VTXDigi/src/VTXBgClusters.cc
@@ -145,8 +145,8 @@ void VTXBgClusters::processEvent( LCEvent * evt ) {
 
       float totMomentum = 0;
       if (_removeDRays) { // check if hit originates from delta-electron 
-        for (int i=0;i<3;++i) 
-          totMomentum+=SimTHit->getMomentum()[i]*SimTHit->getMomentum()[i];
+        for (int ii=0;ii<3;++ii) 
+          totMomentum+=SimTHit->getMomentum()[ii]*SimTHit->getMomentum()[ii];
         totMomentum = sqrt(totMomentum);
         if (totMomentum < _momCut)
           accept = 0;
diff --git a/TrackDigi/VTXDigi/src/VTXDigiProcessor.cc b/TrackDigi/VTXDigi/src/VTXDigiProcessor.cc
index f74b9e7..ead2dca 100644
--- a/TrackDigi/VTXDigi/src/VTXDigiProcessor.cc
+++ b/TrackDigi/VTXDigi/src/VTXDigiProcessor.cc
@@ -196,12 +196,15 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
     }
     catch(DataNotAvailableException &e){
 
-      if (iColl==0)
+      if (iColl==0) {
         streamlog_out(DEBUG) << "Collection " << _colNameVTX.c_str() << " is unavailable in event " << _nEvt << std::endl;
-      else if (iColl==1)
+      }
+      else if (iColl==1) {
         streamlog_out(DEBUG) << "Collection " << _colNameSIT.c_str() << " is unavailable in event " << _nEvt << std::endl;
-      else 
-        streamlog_out(DEBUG) << "Collection " << _colNameSET.c_str() << " is unavailable in event " << _nEvt << std::endl; 
+      }
+      else  {
+        streamlog_out(DEBUG) << "Collection " << _colNameSET.c_str() << " is unavailable in event " << _nEvt << std::endl;
+      }
     }
 
     if( STHcol != 0 ){    
@@ -227,9 +230,9 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
         
         if (_removeDRays) { // check if hit originates from delta-electron 
           float totMomentum = 0;
-          for (int i=0;i<3;++i) 
+          for (int ii=0;ii<3;++ii) 
             {
-              totMomentum+=SimTHit->getMomentum()[i]*SimTHit->getMomentum()[i];
+              totMomentum+=SimTHit->getMomentum()[ii]*SimTHit->getMomentum()[ii];
             }
           totMomentum = sqrt(totMomentum);
           
@@ -285,7 +288,7 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
 
             streamlog_out(DEBUG) << "start smearing along ladders for: " << layer << std::endl;
             
-            int layer = SimTHit->getCellID0() - 1;
+            int layer_ = SimTHit->getCellID0() - 1;
               
             //phi between each ladder
             double deltaPhi = ( 2 * M_PI ) / layerVXD.getNLadders(layer) ;
@@ -295,24 +298,24 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
             int ladderIndex = -1;
             double ladderPhi=999;
               
-            for (int ic=0; ic < layerVXD.getNLadders(layer); ++ic) {
+            for (int ic=0; ic < layerVXD.getNLadders(layer_); ++ic) {
                 
-              ladderPhi = correctPhiRange( layerVXD.getPhi0( layer ) + ic*deltaPhi ) ;
+              ladderPhi = correctPhiRange( layerVXD.getPhi0( layer_ ) + ic*deltaPhi ) ;
                 
               PhiInLocal = hitvec.phi() - ladderPhi;
               double RXY = hitvec.rho();
                 
               // check if point is in range of ladder
-              if (RXY*cos(PhiInLocal) - layerVXD.getSensitiveDistance(layer) > -layerVXD.getSensitiveThickness(layer) && 
-                  RXY*cos(PhiInLocal) - layerVXD.getSensitiveDistance(layer) <  layerVXD.getSensitiveThickness(layer) )
+              if (RXY*cos(PhiInLocal) - layerVXD.getSensitiveDistance(layer_) > -layerVXD.getSensitiveThickness(layer_) && 
+                  RXY*cos(PhiInLocal) - layerVXD.getSensitiveDistance(layer_) <  layerVXD.getSensitiveThickness(layer_) )
                 {
                   ladderIndex = ic;
                   break;
                 }
             }
 
-            double sensitive_width  = layerVXD.getSensitiveWidth(layer);
-            double sensitive_offset = layerVXD.getSensitiveOffset(layer);
+            double sensitive_width  = layerVXD.getSensitiveWidth(layer_);
+            double sensitive_offset = layerVXD.getSensitiveOffset(layer_);
 
             double ladder_incline = correctPhiRange( (M_PI/2.0 ) + ladderPhi );
               
@@ -322,12 +325,12 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
                                  << " Event: " << _nEvt 
                                  << " hit: " << i 
                                  << " of "   << nSimHits
-                                 << "  layer: " << layer 
+                                 << "  layer: " << layer_ 
                                  << "  ladderIndex: " << ladderIndex 
                                  << "  half ladder width " << sensitive_width * 0.5 
                                  << "  u: " <<  u
                                  << "  layer sensitive_offset " << sensitive_offset
-                                 << "  layer phi0 " << layerVXD.getPhi0( layer )
+                                 << "  layer phi0 " << layerVXD.getPhi0( layer_ )
                                  << "  phi: " <<  hitvec.phi()
                                  << "  PhiInLocal: " << PhiInLocal
                                  << "  ladderPhi: " << ladderPhi
@@ -346,7 +349,7 @@ void VTXDigiProcessor::processEvent( LCEvent * evt ) {
             while( tries < 100 )
               {
                   
-                if(tries > 0) streamlog_out(DEBUG) << "retry smearing for " << layer << " " << ladderIndex << " : retries " << tries << std::endl;
+                if(tries > 0) streamlog_out(DEBUG) << "retry smearing for " << layer_ << " " << ladderIndex << " : retries " << tries << std::endl;
                   
                 _pointResoRPhi = _pointResoRPhi_VTX;
                 _pointResoZ    = _pointResoZ_VTX;
diff --git a/TrackDigi/VTXDigi/src/VTXDigitizer.cc b/TrackDigi/VTXDigi/src/VTXDigitizer.cc
index 89c5f4f..bf26f62 100644
--- a/TrackDigi/VTXDigi/src/VTXDigitizer.cc
+++ b/TrackDigi/VTXDigi/src/VTXDigitizer.cc
@@ -395,8 +395,8 @@ void VTXDigitizer::processEvent( LCEvent * evt ) {
           // LCRelationImpl * rel = new LCRelationImpl(recoHit,simTrkHit,float(1.0));
           // RelCol->addElement(rel);
           // Clean Up                
-          for (int i=0; i < int(simTrkHitVec.size()); ++i) {
-            SimTrackerHit * hit = simTrkHitVec[i];
+          for (int ii=0; ii < int(simTrkHitVec.size()); ++ii) {
+            SimTrackerHit * hit = simTrkHitVec[ii];
             delete hit;
           }     
         }          
@@ -564,7 +564,6 @@ void VTXDigitizer::FindLocalPosition(SimTrackerHit * hit,
   
   if (nLadders > 2) { // laddered structure
     //std::cout<<"laddered structure "<<std::endl;
-    int iLadder=0;
     for (int ic=0; ic<nLadders; ++ic) {
       //      PhiLadder = - PI2 + double(ic)*dPhi + Phi0;
       PhiLadder = double(ic)*dPhi + Phi0;
@@ -572,7 +571,6 @@ void VTXDigitizer::FindLocalPosition(SimTrackerHit * hit,
       //cout<<"Phi "<<PhiLadder<<" "<<PhiInLocal<<" "<<PhiInLab<<" "<<_layerThickness[layer]<<" "<<Radius<<endl;
       if (RXY*cos(PhiInLocal)-Radius > -_layerThickness[layer] && 
           RXY*cos(PhiInLocal)-Radius < _layerThickness[layer]) {
-        iLadder = ic;
         break;
       }
       //cout<<"phi ladder "<<PhiLadder<<endl;
@@ -810,14 +808,14 @@ void VTXDigitizer::ProduceHits( SimTrackerHitImplVec & vectorOfHits) {
             double xCurrent,yCurrent;
             TransformCellIDToXY(ix,iy,xCurrent,yCurrent);
             gsl_sf_result result;
-            int status = gsl_sf_erf_Q_e(float((xCurrent - 0.5*_pixelSizeX - xCentre)/sigmaX), &result);
+            /*int status =*/ gsl_sf_erf_Q_e(float((xCurrent - 0.5*_pixelSizeX - xCentre)/sigmaX), &result);
             float LowerBound = 1 - result.val;
-            status = gsl_sf_erf_Q_e(float((xCurrent + 0.5*_pixelSizeX - xCentre)/sigmaX), &result);
+            /*status =*/ gsl_sf_erf_Q_e(float((xCurrent + 0.5*_pixelSizeX - xCentre)/sigmaX), &result);
             float UpperBound = 1 - result.val;
             float integralX = UpperBound - LowerBound;
-            status = gsl_sf_erf_Q_e(float((yCurrent - 0.5*_pixelSizeY - yCentre)/sigmaY), &result);
+            /*status =*/ gsl_sf_erf_Q_e(float((yCurrent - 0.5*_pixelSizeY - yCentre)/sigmaY), &result);
             LowerBound = 1 - result.val;
-            status = gsl_sf_erf_Q_e(float((yCurrent + 0.5*_pixelSizeY - yCentre)/sigmaY), &result);
+            /*status =*/ gsl_sf_erf_Q_e(float((yCurrent + 0.5*_pixelSizeY - yCentre)/sigmaY), &result);
             UpperBound = 1 - result.val;
             float integralY = UpperBound - LowerBound;
             float totCharge = float(spoint.charge)*integralX*integralY;
diff --git a/Tracking/KinkFinder/src/KinkFinder.cc b/Tracking/KinkFinder/src/KinkFinder.cc
index 2d7186c..17bace3 100644
--- a/Tracking/KinkFinder/src/KinkFinder.cc
+++ b/Tracking/KinkFinder/src/KinkFinder.cc
@@ -506,7 +506,7 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 	  if(rInner[i]>_rKinkCut || rInner[j]>_rKinkCut){
 	    float seedj[3];
 	    float refs[3];
-	    float deltaz;
+	    //float deltaz;
 	    float ddx;
 	    float ddy;
 	    float ddz;
@@ -525,7 +525,7 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 	      refs[1]  = helixStart[j]->getReferencePoint()[1];
 	      refs[2]  = helixStart[j]->getReferencePoint()[2];
 	      helixStart[j]->getPointInZ(z, refs, seedj);
-	      deltaz =  zAtEnd[i] - zAtStart[j];
+	      //deltaz =  zAtEnd[i] - zAtStart[j];
 	      ddx = (zout[i].x-zin[j].x);
 	      ddy = (zout[i].y-zin[j].y);
 	      ddz = (zout[i].z-zin[j].z);
@@ -544,7 +544,7 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 	      refs[1]  = helixEnd[j]->getReferencePoint()[1];
 	      refs[2]  = helixEnd[j]->getReferencePoint()[2];
 	      helixEnd[j]->getPointInZ(z, refs, seedj);	      
-	      deltaz =  zAtEnd[i] - zAtEnd[j];
+	      //deltaz =  zAtEnd[i] - zAtEnd[j];
 	      ddx = (zout[i].x-zout[j].x);
 	      ddy = (zout[i].y-zout[j].y);
 	      ddz = (zout[i].z-zout[j].z);
@@ -629,9 +629,9 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 	      }
 	    }
 	    
-	    bool  ok = true;
-	    if(fabs(deltaz)>200)ok=false;
-	    if(fabs(deltaz)>100 && dr > 5.0)ok=false;
+	    //bool  ok = true;
+	    //if(fabs(deltaz)>200)ok=false;
+	    //if(fabs(deltaz)>100 && dr > 5.0)ok=false;
 	    
 	    float deltaRxyCut = -100;
 	    float drCut   = -100;
@@ -681,7 +681,6 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 	    //	    std::cout << i << " : " << j << " dr = " << dr << " ( " << drCut << " )    deltaRxy = " << deltarxy << " ( " << deltaRxyCut << " ) " << std::endl; 
 	    if( (dr<drCut && deltarxy < deltaRxyCut*2) || mcKink){
 	      bool possibleSplit = false;
-	      bool split = false;
 	      rkink = sqrt(xkink*xkink+ykink*ykink);
 
 	      if( (rkink > _rKinkCut && !flipped) || mcKink){
@@ -810,7 +809,7 @@ void KinkFinder::processEvent( LCEvent * evt ) {
 			std::cout << " CAND SPLIT I : " << nhitsi << " ntpc " << ntpci << " nclose " << nclosei << " max " << maxdisti << " fclose : " << fclosei << std::endl; 
 			std::cout << " CAND SPLIT J : " << nhitsj << " ntpc " << ntpcj << " nclose " << nclosej << " max " << maxdistj << " fclose : " << fclosej << std::endl; 
 		      }
-		      if(maxdistj<50 && maxdisti < 50 && fclosej > 0.95 && fclosei > 0.95 && ntpcj+ntpci < _tpcMaxRow+10.)split = true;
+		      //if(maxdistj<50 && maxdisti < 50 && fclosej > 0.95 && fclosei > 0.95 && ntpcj+ntpci < _tpcMaxRow+10.)split = true;
 		      splitDaughters[i].push_back(kinkij);
 		    }
 		  }
diff --git a/Tracking/V0Finder/src/V0Finder.cc b/Tracking/V0Finder/src/V0Finder.cc
index 59d27b3..fca06eb 100644
--- a/Tracking/V0Finder/src/V0Finder.cc
+++ b/Tracking/V0Finder/src/V0Finder.cc
@@ -466,10 +466,10 @@ float V0Finder::Rmin( Track* track ) {
     if(z<zmin)zmin=z;
     if(z>zmax)zmax=z;
   }
-  float tanLambda = track->getTanLambda();
+  //float tanLambda = track->getTanLambda();
   //  std::cout << " V0 Check : " << tanLambda << " z = " << zmin << " - " << zmax << std::endl; 
-  float zzz = zmin;
-  if(tanLambda<0)zzz=zmax;
+  //float zzz = zmin;
+  //if(tanLambda<0)zzz=zmax;
 
   float zstart = 0;
   if(fabs(zmin)<fabs(zmax))zstart = zmin;
